{% extends 'base.html' %}

{% block content %}
<style>
    /* Estilos para melhor visualização no curral */
    body {
        background-color: #f8f9fa;
    }
    
    .form-control {
        font-size: 1.1rem;  
        padding: 0.5rem;    
        border: 2px solid #333;
        height: auto;
    }
    
    .form-label {
        font-size: 1rem;    
        font-weight: bold;
        color: #333;
        margin-bottom: 0.3rem;
    }
    
    .btn-manejo {
        font-size: 1.1rem;  
        padding: 0.6rem 1.2rem; 
        margin: 0.3rem;     
    }
    
    .card {
        border: 2px solid #333;
        margin-bottom: 0.6rem; 
    }
    
    .card-header {
        background-color: #333;
        color: white;
        padding: 0.6rem;    
    }

    .card-header h3 {
        font-size: 1.1rem;  
        margin: 0;
    }
    
    .info-box {
        background-color: #fff;
        border: 1px solid #333; 
        padding: 0.6rem;    
        margin-bottom: 0.6rem; 
    }
    
    .info-text {
        font-size: 0.9rem;  
        margin-bottom: 0.3rem; 
    }
    
    .checkbox-lg {
        width: 18px;       
        height: 18px;      
        margin-right: 6px; 
    }
    
    .checkbox-label {
        font-size: 1rem;   
        font-weight: bold;
    }
    
    .section-divider {
        border-left: 1px solid #333; 
        height: 100%;
        padding-left: 0.6rem; 
    }

    .mb-3 {
        margin-bottom: 0.6rem !important; 
    }

    .p-4 {
        padding: 0.8rem !important; 
    }

    h4 {
        font-size: 1rem;   
        margin-bottom: 0.6rem; 
    }

    h5 {
        font-size: 0.9rem; 
        margin-bottom: 0.4rem; 
    }
    
    /* GMD box mais compacto */
    .alert-info {
        padding: 0.5rem;
        margin-top: 0.5rem !important;
        margin-bottom: 0.5rem !important;
    }
    
    /* Botão de salvar sempre visível */
    .action-buttons {
        position: fixed;
        bottom: 0;
        right: 0;
        background: #f8f9fa;
        padding: 10px;
        border-top: 1px solid #ddd;
        border-left: 1px solid #ddd;
        z-index: 1000;
    }
    
    /* Adicionar padding no final do formulário para dar espaço ao botão fixo */
    .container-fluid {
        padding-bottom: 60px;
    }
    
    /* Notificação temporária */
    .notification {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 25px;
        background-color: #28a745;
        color: white;
        border-radius: 5px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        z-index: 9999;
        font-size: 1.1rem;
        font-weight: bold;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
    }
    
    .notification.show {
        opacity: 1;
    }
    
    /* Estilos para os botões de Bluetooth */
    .bluetooth-btn {
        font-size: 0.9rem;
        padding: 0.3rem 0.6rem;
        margin-left: 0.3rem;
        background-color: #0d6efd;
        color: white;
        border: none;
        border-radius: 4px;
    }
    
    .bluetooth-btn.connected {
        background-color: #198754;
    }
    
    .bluetooth-btn.error {
        background-color: #dc3545;
    }
    
    .bluetooth-status {
        font-size: 0.8rem;
        margin-top: 0.2rem;
        color: #6c757d;
    }
    
    .input-group-append {
        display: flex;
    }
    
    /* Estilos para notificações */
    .notificacao {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 10px 15px;
        background-color: #f8f9fa;
        border-left: 4px solid #007bff;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        border-radius: 4px;
        z-index: 9999;
        opacity: 0;
        transform: translateY(20px);
        transition: opacity 0.3s, transform 0.3s;
        font-size: 14px;
        max-width: 300px;
    }
    
    .notificacao.visivel {
        opacity: 1;
        transform: translateY(0);
    }
    
    .notificacao.info {
        border-left-color: #007bff;
    }
    
    .notificacao.success {
        border-left-color: #28a745;
    }
    
    .notificacao.warning {
        border-left-color: #ffc107;
    }
    
    .notificacao.error {
        border-left-color: #dc3545;
    }
    
    /* Estilos para o modo de campo */
    .field-mode {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .field-mode .form-group {
        margin-bottom: 5px;
    }
    
    .field-mode label {
        font-weight: bold;
        margin-bottom: 2px;
    }
    
    .field-mode input, .field-mode select {
        padding: 8px;
        font-size: 16px;
    }
    
    /* Estilos para os botões de conexão Bluetooth */
    .bt-connect-btn {
        padding: 8px 15px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }
    
    .bt-connect-btn.connected {
        background-color: #28a745;
    }
    
    .bt-connect-btn.error {
        background-color: #dc3545;
    }
    
    .bt-status {
        padding: 8px;
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-bottom: 15px;
    }
    
    /* Estilos para status da balança */
    .bt-status.status-aguarde {
        background-color: #fff3cd;
        border-color: #ffeeba;
        color: #856404;
    }
    
    .bt-status.status-pronto {
        background-color: #d4edda;
        border-color: #c3e6cb;
        color: #155724;
    }
    
    .bt-status.status-congelado {
        background-color: #cce5ff;
        border-color: #b8daff;
        color: #004085;
    }
    
    .bt-status.status-registrado {
        background-color: #d1ecf1;
        border-color: #bee5eb;
        color: #0c5460;
    }
    
    .bt-status.peso-capturado {
        animation: highlight-peso 2s;
    }
    
    @keyframes highlight-peso {
        0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
        100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
    }
    
    /* Estilos para notificações */
    .notificacao {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 10px 15px;
        background-color: #007bff;
        color: white;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        z-index: 1000;
        opacity: 0;
        transform: translateY(-20px);
        transition: opacity 0.3s, transform 0.3s;
    }
    
    .notificacao.visivel {
        opacity: 1;
        transform: translateY(0);
    }
    
    .notificacao.success {
        background-color: #28a745;
    }
    
    .notificacao.error {
        background-color: #dc3545;
    }
    
    .notificacao.warning {
        background-color: #ffc107;
        color: #212529;
    }
    
    /* Estilos para o botão de salvar */
    .save-button-container {
        margin-top: 20px;
        text-align: center;
    }
    
    .save-button {
        padding: 10px 20px;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 16px;
        cursor: pointer;
    }
    
    .save-button:disabled {
        background-color: #6c757d;
        cursor: not-allowed;
    }
    
    .save-button.pulse {
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.05);
            background-color: #218838;
        }
        100% {
            transform: scale(1);
        }
    }
    
    /* Estilos para o modo de automação */
    .automation-toggle {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
    }
    
    .automation-toggle input {
        margin-right: 8px;
    }
    
    .automation-active {
        background-color: #f8f9fa;
        padding: 10px;
        border: 1px solid #28a745;
        border-radius: 4px;
    }
</style>

<!-- Div para notificações temporárias -->
<div id="notification" class="notification"></div>

<div class="container-fluid p-4" style="height: calc(100vh - 100px);">
    <form method="post" id="manejoForm" action="{% url 'manejo_create' %}">
        {% csrf_token %}
        
        <!-- Campos ocultos para armazenar IDs -->
        <input type="hidden" id="animal_id" name="animal_id">
        <input type="hidden" id="lote_id" name="lote_id">
        <input type="hidden" id="pasto_id" name="pasto_id">
        <input type="hidden" id="fazenda_id" name="fazenda_id">
        
        <div class="row h-100">
            <!-- Coluna da Esquerda - Informações do Animal -->
            <div class="col-md-4">
                <div class="card h-100">
                    <div class="card-header">
                        <h3><i class="fas fa-cow me-2"></i>Identificação do Animal</h3>
                    </div>
                    <div class="card-body">
                        <!-- Data do Manejo -->
                        <div class="mb-2">
                            <label for="data" class="form-label">
                                <i class="fas fa-calendar me-2"></i>Data
                            </label>
                            <input type="date" class="form-control" id="data" name="data" required value="{% now 'Y-m-d' %}">
                        </div>

                        <!-- Brinco com botão de conexão Bluetooth -->
                        <div class="mb-2">
                            <label for="brinco" class="form-label">
                                <i class="fas fa-tag me-2"></i>Brinco
                            </label>
                            <div class="input-group">
                                <input type="text" class="form-control" id="brinco" name="brinco" 
                                       placeholder="Digite o brinco" required>
                                <div class="input-group-append">
                                    <button type="button" id="conectarBastao" class="bluetooth-btn" title="Conectar bastão">
                                        <i class="fas fa-bluetooth-b"></i>
                                    </button>
                                </div>
                            </div>
                            <div id="bastaoStatus" class="bluetooth-status"></div>
                        </div>

                        <!-- Informações do Animal -->
                        <div id="animalInfo" class="info-box" style="display: none;">
                            <h4><i class="fas fa-info-circle me-2"></i>Informações</h4>
                            <div id="animalDetails">
                                <p class="info-text"><strong>Brinco:</strong> <span id="animalBrinco"></span></p>
                                <p class="info-text"><strong>Raça:</strong> <span id="animalRaca"></span></p>
                                <p class="info-text"><strong>Categoria:</strong> <span id="animalCategoria"></span></p>
                                <p class="info-text"><strong>Lote:</strong> <span id="animalLote"></span></p>
                                <p class="info-text"><strong>Pasto:</strong> <span id="animalPasto"></span></p>
                            </div>
                            
                            <div id="ultimaPesagem" class="mt-2" style="display: none;">
                                <h4><i class="fas fa-weight me-2"></i>Histórico de Peso</h4>
                                <p class="info-text"><strong>Último Peso:</strong> <span id="ultimoPeso"></span> kg</p>
                                <p class="info-text"><strong>Data:</strong> <span id="ultimaData"></span></p>
                            </div>

                            <div id="gmdInfo" class="alert alert-info mt-2" style="display: none;">
                                <p class="info-text mb-0">
                                    <strong>GMD Atual:</strong> <span id="gmdValor"></span> kg/dia
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Coluna da Direita - Manejos -->
            <div class="col-md-8">
                <div class="row h-100">
                    <!-- Pesagem e Apartação -->
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header">
                                <h3><i class="fas fa-weight me-2"></i>Pesagem e Apartação</h3>
                            </div>
                            <div class="card-body">
                                <!-- Tipo de Manejo -->
                                <div class="mb-2">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="form-check me-3">
                                            <input class="form-check-input checkbox-lg" type="checkbox" id="manejo_desmame" name="manejo_desmame">
                                            <label class="form-check-label checkbox-label" for="manejo_desmame">
                                                <i class="fas fa-baby me-1"></i>Desmame
                                            </label>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Peso com botão de conexão Bluetooth -->
                                <div class="mb-2">
                                    <label for="peso" class="form-label">Peso (kg)</label>
                                    <div class="input-group">
                                        <input type="number" class="form-control" id="peso" name="peso" step="0.01" disabled>
                                        <div class="input-group-append">
                                            <button type="button" id="conectarBalanca" class="bluetooth-btn" title="Conectar balança">
                                                <i class="fas fa-bluetooth-b"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div id="balancaStatus" class="bluetooth-status"></div>
                                </div>
                                <div id="novoGMDInfo" class="alert alert-info mt-2" style="display: none;">
                                    <p class="info-text mb-0">
                                        <strong>Novo GMD:</strong> <span id="novoGMDValor"></span> kg/dia
                                    </p>
                                </div>

                                <!-- Apartação -->
                                <div class="form-check mb-2">
                                    <input class="form-check-input checkbox-lg" type="checkbox" id="fazer_apartacao" name="fazer_apartacao" disabled>
                                    <label class="form-check-label checkbox-label" for="fazer_apartacao">
                                        Fazer Apartação
                                    </label>
                                </div>

                                <div id="apartacao_campos" style="display: none;">
                                    <div class="mb-2">
                                        <label for="peso_referencia" class="form-label">Peso de Referência (kg)</label>
                                        <input type="number" class="form-control" id="peso_referencia" name="peso_referencia" step="0.01">
                                    </div>

                                    <div class="row">
                                        <div class="col-md-6">
                                            <h5>Acima do Peso</h5>
                                            <div class="mb-2">
                                                <label for="lote_acima" class="form-label">Lote</label>
                                                <select class="form-control" id="lote_acima" name="lote_acima">
                                                    <option value="">Selecione</option>
                                                </select>
                                            </div>
                                            <div class="mb-2">
                                                <label for="pasto_acima" class="form-label">Pasto</label>
                                                <select class="form-control" id="pasto_acima" name="pasto_acima">
                                                    <option value="">Selecione</option>
                                                </select>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <h5>Abaixo do Peso</h5>
                                            <div class="mb-2">
                                                <label for="lote_abaixo" class="form-label">Lote</label>
                                                <select class="form-control" id="lote_abaixo" name="lote_abaixo">
                                                    <option value="">Selecione</option>
                                                </select>
                                            </div>
                                            <div class="mb-2">
                                                <label for="pasto_abaixo" class="form-label">Pasto</label>
                                                <select class="form-control" id="pasto_abaixo" name="pasto_abaixo">
                                                    <option value="">Selecione</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Manejo Sanitário -->
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header">
                                <h3><i class="fas fa-syringe me-2"></i>Manejo Sanitário</h3>
                            </div>
                            <div class="card-body">
                                <div class="form-check mb-2">
                                    <input class="form-check-input checkbox-lg" type="checkbox" id="fazer_manejo" name="fazer_manejo" disabled>
                                    <label class="form-check-label checkbox-label" for="fazer_manejo">
                                        Fazer Manejo Sanitário
                                    </label>
                                </div>

                                <div id="manejo_sanitario_campos" style="display: none;">
                                    <div class="mb-2">
                                        <label for="insumo" class="form-label">Insumo</label>
                                        <input type="text" class="form-control" id="insumo" name="insumo">
                                    </div>

                                    <div class="mb-2">
                                        <label for="tipo_manejo" class="form-label">Tipo de Manejo</label>
                                        <input type="text" class="form-control" id="tipo_manejo" name="tipo_manejo">
                                    </div>

                                    <div class="mb-2">
                                        <label for="dias_proximo" class="form-label">Dias p/ Próximo</label>
                                        <input type="number" class="form-control" id="dias_proximo" name="dias_proximo">
                                    </div>

                                    <div class="mb-2">
                                        <label for="observacao" class="form-label">Observação</label>
                                        <textarea class="form-control" id="observacao" name="observacao" rows="2"></textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Botões fixos no rodapé -->
        <div class="position-fixed bottom-0 start-0 w-100 bg-light p-2" style="border-top: 1px solid #ddd; z-index: 1000;">
            <div class="d-flex justify-content-center gap-2 align-items-center">
                <label for="toggleAutomation" class="form-label mb-0 me-1">Automação</label>
                <label class="switch">
                    <input type="checkbox" id="toggleAutomation">
                    <span class="slider round"></span>
                </label>
                <button type="submit" id="submitButton" class="btn btn-primary btn-sm ms-2" disabled>
                    <i class="fas fa-save me-1"></i><span class="button-text">Salvar</span>
                </button>
                <button type="reset" class="btn btn-secondary btn-sm">
                    <i class="fas fa-undo me-1"></i>Limpar
                </button>
                <style>
                .switch {
                    position: relative;
                    display: inline-block;
                    width: 50px;
                    height: 28px;
                }

                .switch input { 
                    opacity: 0;
                    width: 0;
                    height: 0;
                }

                .slider {
                    position: absolute;
                    cursor: pointer;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background-color: #ccc;
                    transition: .4s;
                }

                .slider:before {
                    position: absolute;
                    content: "";
                    height: 20px;
                    width: 20px;
                    left: 4px;
                    bottom: 4px;
                    background-color: white;
                    transition: .4s;
                }

                input:checked + .slider {
                    background-color: #2196F3;
                }

                input:checked + .slider:before {
                    transform: translateX(22px);
                }

                /* Rounded sliders */
                .slider.round {
                    border-radius: 28px;
                }

                .slider.round:before {
                    border-radius: 50%;
                }
                </style>
            </div>
        </div>
    </form>
</div>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Elementos do DOM
    const form = document.getElementById('manejoForm');
    const brincoInput = document.getElementById('brinco');
    const pesoInput = document.getElementById('peso');
    const dataInput = document.getElementById('data');
    const submitButton = document.getElementById('submitButton');
    const toggleAutomation = document.getElementById('toggleAutomation');
    const fazerManejoCheckbox = document.getElementById('fazer_manejo');
    const manejoSanitarioCampos = document.getElementById('manejo_sanitario_campos');
    const fazerApartacaoCheckbox = document.getElementById('fazer_apartacao');
    const apartacaoCampos = document.getElementById('apartacao_campos');
    
    // Adicionar elementos que faltam para manejo sanitário
    const insumoInput = document.getElementById('insumo');
    const tipoManejoInput = document.getElementById('tipo_manejo');
    const diasProximoManejoInput = document.getElementById('dias_proximo');
    const observacaoTextarea = document.getElementById('observacao');

    // Variáveis de controle
    let automationActive = false;
    let autoPesoTriggered = false;

    // Inicializar variáveis globais de controle
    if (typeof window.formSubmitInProgress === 'undefined') {
        window.formSubmitInProgress = false;
    }
    if (typeof window.registroEmAndamento === 'undefined') {
        window.registroEmAndamento = false;
    }
    if (typeof window.saveButtonInterval === 'undefined') {
        window.saveButtonInterval = null;
    }
    if (typeof window.brincoTimeout === 'undefined') {
        window.brincoTimeout = null;
    }

    // Função para reproduzir beep
    function beep() {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.value = 800;
        gainNode.gain.value = 0.5;
        
        oscillator.start();
        setTimeout(function() {
            oscillator.stop();
            ctx.close();
        }, 150);
    }

    // Função para animar o botão de salvar
    function animateSaveButton() {
        // Se já tiver um envio de formulário em andamento, não prosseguir
        if (window.formSubmitInProgress) {
            console.log("Envio de formulário já em andamento, ignorando requisição");
            return;
        }
        
        window.formSubmitInProgress = true;
        const buttonText = submitButton.querySelector('.button-text');
        let progress = 0;
        const originalText = buttonText.textContent;
        
        buttonText.textContent = 'Salvando... 0%';
        
        const interval = setInterval(function() {
            progress += 5;
            buttonText.textContent = `Salvando... ${progress}%`;
            
            if (progress >= 100) {
                clearInterval(interval);
                buttonText.textContent = originalText;
                // Enviar o formulário diretamente 
                registrarManejo(new FormData(form));
            }
        }, 50);
        
        // Limpar intervalo caso demore muito (segurança)
        setTimeout(() => {
            clearInterval(interval);
            buttonText.textContent = originalText;
            window.formSubmitInProgress = false;
        }, 10000);
        
        // Salvar referência global para poder limpar em outros lugares
        window.saveButtonInterval = interval;
    }

    // Função para buscar animal
    async function buscarAnimal(brinco) {
        try {
            const response = await fetch(`/api/buscar_animal/${brinco}/`);
            const data = await response.json();
            
            if (data.success) {
                beep();
                document.getElementById('animalInfo').style.display = 'block';
                document.getElementById('animalBrinco').textContent = data.animal.brinco;
                document.getElementById('animalRaca').textContent = data.animal.raca;
                document.getElementById('animalCategoria').textContent = data.animal.categoria;
                document.getElementById('animalLote').textContent = data.animal.lote;
                document.getElementById('animalPasto').textContent = data.animal.pasto || "Não atribuído";
                
                // Atualizar dados de última pesagem
                if (data.ultima_pesagem) {
                    document.getElementById('ultimaPesagem').style.display = 'block';
                    document.getElementById('ultimoPeso').textContent = data.ultima_pesagem.peso;
                    document.getElementById('ultimaData').textContent = data.ultima_pesagem.data;
                    
                    // Log detalhado para depuração
                    console.log("Dados da última pesagem:", data.ultima_pesagem);
                    console.log("GMD recebido da API:", data.gmd);
                    
                    // Mostrar GMD histórico se disponível
                    if (data.gmd !== null && data.gmd !== undefined) {
                        console.log("Mostrando GMD histórico:", data.gmd);
                        document.getElementById('gmdValor').textContent = data.gmd;
                        document.getElementById('gmdInfo').style.display = 'block';
                    } else {
                        console.log("GMD histórico não disponível");
                        document.getElementById('gmdInfo').style.display = 'none';
                    }
                } else {
                    console.log("Não há dados de última pesagem disponíveis");
                    document.getElementById('ultimaPesagem').style.display = 'none';
                    document.getElementById('gmdInfo').style.display = 'none';
                }
                
                // Habilitar campos
                pesoInput.disabled = false;
                fazerManejoCheckbox.disabled = false;
                fazerApartacaoCheckbox.disabled = false;
                submitButton.disabled = false;
                
                // Verificar os estados atuais das checkboxes para decidir a visibilidade
                if (fazerManejoCheckbox.checked) {
                    manejoSanitarioCampos.style.display = 'block';
                } else {
                    manejoSanitarioCampos.style.display = 'none';
                }
                
                if (fazerApartacaoCheckbox.checked) {
                    apartacaoCampos.style.display = 'block';
                    // Se a fazenda foi carregada, recarregar lotes e pastos
                    if (document.getElementById('fazenda_id').value) {
                        carregarLotesPastosMantendoSelecao(
                            document.getElementById('fazenda_id').value,
                            document.getElementById('lote_acima').value,
                            document.getElementById('pasto_acima').value,
                            document.getElementById('lote_abaixo').value,
                            document.getElementById('pasto_abaixo').value
                        );
                    }
                } else {
                    apartacaoCampos.style.display = 'none';
                }
                
                document.getElementById('novoGMDInfo').style.display = 'none';
                
                // Adicionar ID do animal ao formulário
                document.getElementById('animal_id').value = data.animal.id;
                document.getElementById('lote_id').value = data.animal.lote_id;
                document.getElementById('pasto_id').value = data.animal.pasto_id;
                document.getElementById('fazenda_id').value = data.animal.fazenda_id;
                
                // Limpar o campo de peso para nova entrada
                pesoInput.value = "";
                
                if (automationActive) {
                    setTimeout(() => {
                        pesoInput.focus();
                        beep();
                    }, 500);
                }
            } else {
                const notification = document.getElementById('notification');
                notification.textContent = data.message || 'Animal não encontrado';
                notification.classList.add('show');
                setTimeout(() => notification.classList.remove('show'), 3000);
                document.getElementById('animalInfo').style.display = 'none';
                document.getElementById('ultimaPesagem').style.display = 'none';
                document.getElementById('gmdInfo').style.display = 'none';
                document.getElementById('novoGMDInfo').style.display = 'none';
                
                // Desabilitar campos
                pesoInput.disabled = true;
                fazerManejoCheckbox.disabled = true;
                fazerApartacaoCheckbox.disabled = true;
                submitButton.disabled = true;
            }
        } catch (error) {
            console.error('Erro ao buscar animal:', error);
            const notification = document.getElementById('notification');
            notification.textContent = 'Erro ao buscar animal';
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 3000);
        }
    }
    
    // Função para calcular o novo GMD baseado no peso atual
    function calcularNovoGMD() {
        const novoPeso = parseFloat(pesoInput.value);
        const ultimoPesoElement = document.getElementById('ultimoPeso');
        const ultimaDataElement = document.getElementById('ultimaData');
        
        // Log para depuração
        console.log("Calculando novo GMD...");
        console.log("Novo peso:", novoPeso);
        
        if (novoPeso && ultimoPesoElement && ultimaDataElement) {
            const ultimoPeso = parseFloat(ultimoPesoElement.textContent);
            const ultimaData = new Date(ultimaDataElement.textContent);
            const novaData = new Date(dataInput.value);
            
            console.log("Último peso:", ultimoPeso);
            console.log("Última data:", ultimaData);
            console.log("Nova data:", novaData);
            
            if (ultimoPeso && ultimaData && novaData && !isNaN(ultimoPeso) && !isNaN(novoPeso)) {
                const diffDays = Math.floor((novaData - ultimaData) / (1000 * 60 * 60 * 24));
                
                console.log("Diferença em dias:", diffDays);
                
                if (diffDays > 0) {
                    const novoGMD = (novoPeso - ultimoPeso) / diffDays;
                    console.log("Novo GMD calculado:", novoGMD.toFixed(3));
                    
                    document.getElementById('novoGMDValor').textContent = novoGMD.toFixed(3);
                    document.getElementById('novoGMDInfo').style.display = 'block';
                    
                    if (automationActive && !autoPesoTriggered) {
                        autoPesoTriggered = true;
                        setTimeout(() => {
                            beep();
                            animateSaveButton();
                        }, 1000);
                    }
                } else {
                    console.log("Diferença em dias <= 0, não mostrando GMD");
                    document.getElementById('novoGMDInfo').style.display = 'none';
                }
            } else {
                console.log("Dados inválidos para cálculo de GMD");
                document.getElementById('novoGMDInfo').style.display = 'none';
            }
        } else {
            console.log("Faltam dados para cálculo de GMD");
            document.getElementById('novoGMDInfo').style.display = 'none';
        }
    }

    // Função para carregar lotes por fazenda
    async function carregarLotesPorFazenda(fazendaId) {
        try {
            const response = await fetch(`/api/lotes_por_fazenda/${fazendaId}/`);
            const data = await response.json();
            
            if (data.success) {
                const loteAcima = document.getElementById('lote_acima');
                const loteAbaixo = document.getElementById('lote_abaixo');
                
                loteAcima.innerHTML = '<option value="">Selecione</option>';
                loteAbaixo.innerHTML = '<option value="">Selecione</option>';
                
                data.lotes.forEach(lote => {
                    const option = document.createElement('option');
                    option.value = lote.id;
                    option.textContent = lote.nome;  // Isso está correto pois a API agora retorna str(lote)
                    
                    loteAcima.appendChild(option.cloneNode(true));
                    loteAbaixo.appendChild(option);
                });
            }
        } catch (error) {
            console.error('Erro ao carregar lotes:', error);
            const notification = document.getElementById('notification');
            notification.textContent = 'Erro ao carregar lotes';
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 3000);
        }
    }

    // Função para carregar pastos por fazenda
    async function carregarPastosPorFazenda(fazendaId) {
        try {
            const response = await fetch(`/api/pastos_por_fazenda/${fazendaId}/`);
            const data = await response.json();
            
            if (data.success) {
                const pastoAcima = document.getElementById('pasto_acima');
                const pastoAbaixo = document.getElementById('pasto_abaixo');
                
                pastoAcima.innerHTML = '<option value="">Selecione</option>';
                pastoAbaixo.innerHTML = '<option value="">Selecione</option>';
                
                data.pastos.forEach(pasto => {
                    const option = document.createElement('option');
                    option.value = pasto.id;
                    option.textContent = pasto.nome;
                    
                    pastoAcima.appendChild(option.cloneNode(true));
                    pastoAbaixo.appendChild(option);
                });
            }
        } catch (error) {
            console.error('Erro ao carregar pastos:', error);
            const notification = document.getElementById('notification');
            notification.textContent = 'Erro ao carregar pastos';
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 3000);
        }
    }

    // Função para registrar manejo
    async function registrarManejo(formData) {
        try {
            // Se já tiver um envio em andamento, não prosseguir
            if (window.registroEmAndamento) {
                console.log("Registro já em andamento, ignorando requisição duplicada");
                return;
            }
            
            window.registroEmAndamento = true;
            
            const response = await fetch('/api/registrar_manejo/', {
                method: 'POST',
                body: formData
            });
            const data = await response.json();
            
            // Garantir que o intervalo da animação seja limpo
            if (window.saveButtonInterval) {
                clearInterval(window.saveButtonInterval);
                window.saveButtonInterval = null;
            }
            
            // Reset das flags de controle
            window.formSubmitInProgress = false;
            window.registroEmAndamento = false;
            
            // Reset do texto do botão
            const buttonText = submitButton.querySelector('.button-text');
            buttonText.textContent = 'Salvar';
            
            if (data.success) {
                beep();
                const notification = document.getElementById('notification');
                notification.textContent = data.message;
                notification.classList.add('show');
                setTimeout(() => notification.classList.remove('show'), 3000);
                
                // Salvar estados dos checkboxes e outros valores de configuração
                const fazerManejoChecked = fazerManejoCheckbox.checked;
                const fazerApartacaoChecked = fazerApartacaoCheckbox.checked;
                const manejoDesmameChecked = document.getElementById('manejo_desmame').checked;
                
                // Preservar os valores dos selectboxes de lote e pasto
                const loteAcimaValue = document.getElementById('lote_acima').value;
                const pastoAcimaValue = document.getElementById('pasto_acima').value;
                const loteAbaixoValue = document.getElementById('lote_abaixo').value;
                const pastoAbaixoValue = document.getElementById('pasto_abaixo').value;
                
                // Salvar valores atuais dos campos que devem ser preservados
                const insumoValue = insumoInput.value;
                const tipoManejoValue = tipoManejoInput.value;
                const diasProximoValue = diasProximoManejoInput.value;
                const observacaoValue = observacaoTextarea.value;
                const pesoReferenciaValue = document.getElementById('peso_referencia') ? 
                    document.getElementById('peso_referencia').value : '';
                
                // Limpar apenas o brinco e peso - os únicos campos que devem ser resetados
                brincoInput.value = '';
                pesoInput.value = '';
                
                // Restaurar estados dos checkboxes
                fazerManejoCheckbox.checked = fazerManejoChecked;
                fazerApartacaoCheckbox.checked = fazerApartacaoChecked;
                document.getElementById('manejo_desmame').checked = manejoDesmameChecked;
                
                // Desabilitar apenas alguns campos
                pesoInput.disabled = true;
                submitButton.disabled = true;
                
                // Não desabilitar os checkboxes
                fazerManejoCheckbox.disabled = false;
                fazerApartacaoCheckbox.disabled = false;
                
                // Restaurar valores nos campos que devem ser preservados
                insumoInput.value = insumoValue;
                tipoManejoInput.value = tipoManejoValue;
                diasProximoManejoInput.value = diasProximoValue;
                observacaoTextarea.value = observacaoValue;
                
                // Restaurar valor do peso de referência
                const pesoReferenciaInput = document.getElementById('peso_referencia');
                if (pesoReferenciaInput) {
                    pesoReferenciaInput.value = pesoReferenciaValue;
                }
                
                // Esconder informações
                document.getElementById('animalInfo').style.display = 'none';
                document.getElementById('ultimaPesagem').style.display = 'none';
                document.getElementById('gmdInfo').style.display = 'none';
                document.getElementById('novoGMDInfo').style.display = 'none';
                
                // Manter visibilidade dos campos de manejo e apartação baseado no estado anterior
                setTimeout(() => {
                    // Garantir que os campos sejam exibidos após o reset do formulário
                    // se as checkboxes correspondentes estiverem marcadas
                    manejoSanitarioCampos.style.display = fazerManejoCheckbox.checked ? 'block' : 'none';
                    apartacaoCampos.style.display = fazerApartacaoCheckbox.checked ? 'block' : 'none';
                    
                    // Se a checkbox de apartação estiver marcada, recarregar os lotes e pastos
                    if (fazerApartacaoCheckbox.checked && document.getElementById('fazenda_id').value) {
                        carregarLotesPastosMantendoSelecao(
                            document.getElementById('fazenda_id').value,
                            loteAcimaValue,
                            pastoAcimaValue,
                            loteAbaixoValue,
                            pastoAbaixoValue
                        );
                    } else {
                        // Se não tiver carregando novos lotes/pastos, restaurar diretamente
                        setTimeout(() => {
                            document.getElementById('lote_acima').value = loteAcimaValue;
                            document.getElementById('pasto_acima').value = pastoAcimaValue;
                            document.getElementById('lote_abaixo').value = loteAbaixoValue;
                            document.getElementById('pasto_abaixo').value = pastoAbaixoValue;
                        }, 100);
                    }
                }, 100);
                
                // Resetar variáveis de controle
                autoPesoTriggered = false;
                
                // Se automação está ativa, focar no brinco
                if (automationActive) {
                    setTimeout(() => {
                        brincoInput.focus();
                        beep();
                    }, 500);
                }
            } else {
                beep();
                const notification = document.getElementById('notification');
                notification.textContent = data.message;
                notification.classList.add('show');
                setTimeout(() => notification.classList.remove('show'), 3000);
            }
        } catch (error) {
            console.error('Erro ao registrar manejo:', error);
            const notification = document.getElementById('notification');
            notification.textContent = 'Erro ao registrar manejo';
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 3000);
        }
    }

    // Função para carregar lotes e pastos mantendo a seleção atual
    function carregarLotesPastosMantendoSelecao(fazendaId, loteAcimaValue, pastoAcimaValue, loteAbaixoValue, pastoAbaixoValue) {
        // Primeiro carregar os lotes
        fetch(`/api/buscar_lotes_por_fazenda/${fazendaId}/`)
            .then(response => response.json())
            .then(data => {
                const loteAcimaSelect = document.getElementById('lote_acima');
                const loteAbaixoSelect = document.getElementById('lote_abaixo');
                
                // Limpar opções atuais
                loteAcimaSelect.innerHTML = '<option value="">Selecione</option>';
                loteAbaixoSelect.innerHTML = '<option value="">Selecione</option>';
                
                // Adicionar novas opções
                data.lotes.forEach(lote => {
                    loteAcimaSelect.add(new Option(lote.nome, lote.id));
                    loteAbaixoSelect.add(new Option(lote.nome, lote.id));
                });
                
                // Restaurar valores selecionados
                loteAcimaSelect.value = loteAcimaValue;
                loteAbaixoSelect.value = loteAbaixoValue;
            })
            .catch(error => console.error('Erro ao carregar lotes:', error));
        
        // Depois carregar os pastos
        fetch(`/api/buscar_pastos_por_fazenda/${fazendaId}/`)
            .then(response => response.json())
            .then(data => {
                const pastoAcimaSelect = document.getElementById('pasto_acima');
                const pastoAbaixoSelect = document.getElementById('pasto_abaixo');
                
                // Limpar opções atuais
                pastoAcimaSelect.innerHTML = '<option value="">Selecione</option>';
                pastoAbaixoSelect.innerHTML = '<option value="">Selecione</option>';
                
                // Adicionar novas opções
                data.pastos.forEach(pasto => {
                    pastoAcimaSelect.add(new Option(pasto.nome, pasto.id));
                    pastoAbaixoSelect.add(new Option(pasto.nome, pasto.id));
                });
                
                // Restaurar valores selecionados
                pastoAcimaSelect.value = pastoAcimaValue;
                pastoAbaixoSelect.value = pastoAbaixoValue;
            })
            .catch(error => console.error('Erro ao carregar pastos:', error));
    }

    // Função para mostrar notificações temporárias
    function mostrarNotificacao(mensagem, tipo = 'info', duracao = 3000) {
        // Criar elemento de notificação
        const notificacao = document.createElement('div');
        notificacao.className = `notificacao ${tipo}`;
        notificacao.textContent = mensagem;
        
        // Adicionar ao corpo do documento
        document.body.appendChild(notificacao);
        
        // Mostrar com animação
        setTimeout(() => {
            notificacao.classList.add('visivel');
        }, 10);
        
        // Remover após a duração especificada
        setTimeout(() => {
            notificacao.classList.remove('visivel');
            setTimeout(() => {
                document.body.removeChild(notificacao);
            }, 300); // Tempo da animação de saída
        }, duracao);
    }

    // Variáveis para controle do Bluetooth
    let bastaoDevice = null;
    let balancaDevice = null;
    let bastaoCharacteristic = null;
    let balancaCharacteristic = null;
    let bastaoNotificationsStarted = false;
    let balancaNotificationsStarted = false;
    let bastaoReadInterval = null;
    let balancaReadInterval = null;
    let ultimoBrincoLido = ''; // Armazenar o último brinco lido para evitar duplicatas
    let ultimaLeituraBrinco = 0; // Timestamp da última leitura válida
    let gattOperationInProgress = false; // Flag para controlar operações GATT
    let gattOperationQueue = []; // Fila de operações GATT
    
    // Variáveis para controle do estado da balança
    let pesoAtual = 0;
    let statusBalanca = 'N';
    let ultimoFrame = '';

    // Função para executar operações GATT em fila
    async function executeGattOperation(operation) {
        return new Promise((resolve, reject) => {
            // Adicionar operação à fila
            gattOperationQueue.push({
                operation: operation,
                resolve: resolve,
                reject: reject,
                retryCount: 0,
                maxRetries: 3
            });
            
            // Se não houver operação em andamento, processa a fila
            if (!gattOperationInProgress) {
                processGattQueue();
            }
        });
    }
    
    // Função para processar a fila de operações GATT
    async function processGattQueue() {
        if (gattOperationQueue.length === 0) {
            gattOperationInProgress = false;
            return;
        }
        
        gattOperationInProgress = true;
        const nextOperation = gattOperationQueue.shift();
        
        try {
            // Executar a operação
            const result = await nextOperation.operation();
            nextOperation.resolve(result);
            console.log('Operação GATT concluída com sucesso');
        } catch (error) {
            console.warn('Erro na operação GATT:', error.message);
            
            // Verificar se é um erro de "GATT operation already in progress"
            if (error.message.includes('GATT operation already in progress') && 
                nextOperation.retryCount < nextOperation.maxRetries) {
                
                console.log(`Tentando novamente operação GATT (${nextOperation.retryCount + 1}/${nextOperation.maxRetries})`);
                nextOperation.retryCount++;
                
                // Colocar a operação de volta na fila (no início)
                gattOperationQueue.unshift(nextOperation);
                
                // Aguardar um tempo maior antes de tentar novamente
                setTimeout(() => {
                    processGattQueue();
                }, 500); // Aumentado para 500ms para dar mais tempo entre tentativas
                return;
            } else {
                // Se excedeu o número de tentativas ou é outro tipo de erro, rejeita a promessa
                nextOperation.reject(error);
            }
        } finally {
            // Se houve return no bloco catch para retry, não executamos o restante
            // Caso contrário, continuamos processando a fila após um delay
            setTimeout(() => {
                processGattQueue();
            }, 200); // Aumentado para 200ms para evitar sobrecarga
        }
    }

    // Função para conectar ao bastão de leitura de brinco
    async function conectarBastao() {
        try {
            const bastaoStatusDiv = document.getElementById('bastaoStatus');
            bastaoStatusDiv.textContent = "Procurando dispositivos...";
            
            // Solicitar dispositivo Bluetooth com opções mais abrangentes
            bastaoDevice = await navigator.bluetooth.requestDevice({
                // Aceitar qualquer dispositivo Bluetooth disponível
                acceptAllDevices: true,
                // Incluir serviços SPP e outros comuns
                optionalServices: [
                    // Serviço UART padrão
                    '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
                    // Serviço SPP (Serial Port Profile)
                    '00001101-0000-1000-8000-00805f9b34fb',
                    // Outros serviços comuns
                    'battery_service',
                    '0000180a-0000-1000-8000-00805f9b34fb', // Device Information
                    'device_information',
                    // Serviços genéricos
                    '00001800-0000-1000-8000-00805f9b34fb', // Generic Access
                    '00001801-0000-1000-8000-00805f9b34fb', // Generic Attribute
                    // Serviço HID (Human Interface Device) - comum em leitores
                    '00001812-0000-1000-8000-00805f9b34fb',
                    // Serviços adicionais que podem estar presentes em leitores
                    '0000ffe0-0000-1000-8000-00805f9b34fb',
                    '0000ffe1-0000-1000-8000-00805f9b34fb',
                    '0000fff0-0000-1000-8000-00805f9b34fb',
                    '0000180f-0000-1000-8000-00805f9b34fb'  // Battery Service
                ]
            });
            
            bastaoStatusDiv.textContent = "Conectando ao bastão...";
            const conectarBastaoBtn = document.getElementById('conectarBastao');
            conectarBastaoBtn.classList.add('connected');
            
            // Adicionar listener para desconexão
            bastaoDevice.addEventListener('gattserverdisconnected', onBastaoDisconnected);
            
            // Conectar ao GATT server
            const server = await bastaoDevice.gatt.connect();
            
            // Obter todos os serviços disponíveis
            const services = await executeGattOperation(async () => {
                return await server.getPrimaryServices();
            });
            
            console.log('Serviços disponíveis:', services.map(s => s.uuid));
            
            if (services.length === 0) {
                throw new Error('Nenhum serviço disponível no dispositivo');
            }
            
            // Lista de serviços a tentar, em ordem de prioridade
            const servicesToTry = [
                // Serviço SPP (Serial Port Profile)
                '00001101-0000-1000-8000-00805f9b34fb',
                // Serviço UART padrão
                '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
                // Serviços comuns em leitores
                '0000ffe0-0000-1000-8000-00805f9b34fb',
                '0000fff0-0000-1000-8000-00805f9b34fb',
                // Serviço HID
                '00001812-0000-1000-8000-00805f9b34fb',
                // Outros serviços comuns
                '0000180a-0000-1000-8000-00805f9b34fb',
                'device_information'
            ];
            
            // Tentar obter serviço em ordem de prioridade
            let service = null;
            
            // Primeiro tenta os serviços conhecidos
            for (const serviceUuid of servicesToTry) {
                try {
                    service = await executeGattOperation(async () => {
                        return await server.getPrimaryService(serviceUuid);
                    });
                    console.log('Serviço encontrado:', serviceUuid);
                    break;
                } catch (err) {
                    console.log('Serviço não encontrado:', serviceUuid);
                }
            }
            
            // Se não encontrou nenhum dos serviços conhecidos, usa o primeiro disponível
            if (!service && services.length > 0) {
                service = services[0];
                console.log('Usando primeiro serviço disponível:', service.uuid);
            }
            
            if (!service) {
                throw new Error('Não foi possível obter um serviço utilizável');
            }
            
            // Obter todas as características disponíveis
            const characteristics = await executeGattOperation(async () => {
                return await service.getCharacteristics();
            });
            
            console.log('Características disponíveis:', characteristics.map(c => c.uuid));
            
            // Exibir propriedades de cada característica para depuração
            for (const char of characteristics) {
                console.log(`Propriedades da característica ${char.uuid}:`, {
                    read: char.properties.read,
                    write: char.properties.write,
                    notify: char.properties.notify,
                    indicate: char.properties.indicate,
                    writeWithoutResponse: char.properties.writeWithoutResponse
                });
            }
            
            if (characteristics.length === 0) {
                throw new Error('Nenhuma característica disponível no serviço');
            }
            
            // Lista de características a tentar para RX, em ordem de prioridade
            const rxCharacteristicsToTry = [
                // Característica RX UART padrão
                '6e400003-b5a3-f393-e0a9-e50e24dcca9e',
                // Característica SPP
                '00001101-0000-1000-8000-00805f9b34fb',
                // Características comuns em leitores
                '0000ffe1-0000-1000-8000-00805f9b34fb',
                '0000fff1-0000-1000-8000-00805f9b34fb',
                // Características de informação do dispositivo que podem conter dados úteis
                '00002a23-0000-1000-8000-00805f9b34fb', // System ID
                '00002a24-0000-1000-8000-00805f9b34fb', // Model Number
                '00002a25-0000-1000-8000-00805f9b34fb', // Serial Number
                '00002a26-0000-1000-8000-00805f9b34fb', // Firmware Revision
                '00002a27-0000-1000-8000-00805f9b34fb', // Hardware Revision
                '00002a28-0000-1000-8000-00805f9b34fb', // Software Revision
                '00002a29-0000-1000-8000-00805f9b34fb'  // Manufacturer Name
            ];
            
            // Tentar encontrar uma característica que suporte notificações primeiro
            bastaoCharacteristic = null;
            
            // Primeiro tenta as características conhecidas
            for (const charUuid of rxCharacteristicsToTry) {
                try {
                    bastaoCharacteristic = await executeGattOperation(async () => {
                        return await service.getCharacteristic(charUuid);
                    });
                    console.log('Característica encontrada:', charUuid);
                    break;
                } catch (err) {
                    console.log('Característica não encontrada:', charUuid);
                }
            }
            
            // Se não encontrou, procura por qualquer característica que suporte notificações
            if (!bastaoCharacteristic) {
                const notifyCharacteristics = characteristics.filter(
                    char => char.properties.notify || char.properties.indicate
                );
                
                if (notifyCharacteristics.length > 0) {
                    bastaoCharacteristic = notifyCharacteristics[0];
                    console.log('Usando característica com notificação:', bastaoCharacteristic.uuid);
                } else {
                    // Se não houver características com notificação, use uma que suporte leitura
                    const readableCharacteristics = characteristics.filter(
                        char => char.properties.read
                    );
                    
                    if (readableCharacteristics.length > 0) {
                        bastaoCharacteristic = readableCharacteristics[0];
                        console.log('Usando característica com leitura:', bastaoCharacteristic.uuid);
                    } else if (characteristics.length > 0) {
                        bastaoCharacteristic = characteristics[0];
                        console.log('Usando primeira característica disponível:', bastaoCharacteristic.uuid);
                    }
                }
            }
            
            if (!bastaoCharacteristic) {
                throw new Error('Não foi possível obter uma característica utilizável');
            }
            
            // Configurar o modo de leitura baseado nas propriedades da característica
            if (bastaoCharacteristic.properties.notify) {
                // Modo de notificação
                await executeGattOperation(async () => {
                    await bastaoCharacteristic.startNotifications();
                });
                
                bastaoNotificationsStarted = true;
                bastaoCharacteristic.addEventListener('characteristicvaluechanged', handleBastaoValueChanged);
                console.log('Modo de notificação ativado');
                
                // Limpar qualquer intervalo de leitura existente
                if (bastaoReadInterval) {
                    clearInterval(bastaoReadInterval);
                    bastaoReadInterval = null;
                }
            } else if (bastaoCharacteristic.properties.read) {
                // Modo de leitura periódica
                bastaoNotificationsStarted = false;
                console.log('Modo de leitura periódica ativado');
                
                // Configurar leitura periódica a cada 500ms (mais frequente para capturar leituras)
                if (bastaoReadInterval) {
                    clearInterval(bastaoReadInterval);
                }
                
                // Contador de erros consecutivos para controle de reconexão
                let errorCount = 0;
                const MAX_ERRORS = 5;
                
                bastaoReadInterval = setInterval(async () => {
                    try {
                        // Verificar se o dispositivo ainda está conectado antes de tentar ler
                        if (!bastaoDevice || !bastaoDevice.gatt || !bastaoDevice.gatt.connected) {
                            console.warn('Dispositivo desconectado, tentando reconectar...');
                            try {
                                if (bastaoDevice) {
                                    await bastaoDevice.gatt.connect();
                                    console.log('Reconectado com sucesso');
                                    // Resetar contador de erros após reconexão bem-sucedida
                                    errorCount = 0;
                                }
                            } catch (reconnectError) {
                                console.error('Falha na reconexão:', reconnectError);
                                return; // Sair e tentar novamente no próximo intervalo
                            }
                        }
                        
                        // Tentar ler o valor com tratamento especial para "GATT operation failed"
                        try {
                            const value = await executeGattOperation(async () => {
                                return await bastaoCharacteristic.readValue();
                            });
                            
                            // Leitura bem-sucedida, resetar contador de erros
                            errorCount = 0;
                            handleBastaoValueChanged({ target: { value } });
                        } catch (readError) {
                            // Tratamento especial para "GATT operation failed"
                            if (readError.message.includes('GATT operation failed')) {
                                console.warn('Erro de operação GATT, tentando método alternativo...');
                                
                                // Tentar método alternativo: escrever um comando e depois ler
                                try {
                                    // Se a característica suporta escrita, enviar comando de leitura
                                    if (bastaoCharacteristic.properties.write || 
                                        bastaoCharacteristic.properties.writeWithoutResponse) {
                                        
                                        // Comando genérico para solicitar dados (0x01)
                                        const cmd = new Uint8Array([0x01]);
                                        
                                        // Escrever comando
                                        if (bastaoCharacteristic.properties.write) {
                                            await executeGattOperation(async () => {
                                                return await bastaoCharacteristic.writeValue(cmd);
                                            });
                                        } else {
                                            await executeGattOperation(async () => {
                                                return await bastaoCharacteristic.writeValueWithoutResponse(cmd);
                                            });
                                        }
                                        
                                        // Pequeno delay antes de ler
                                        await new Promise(resolve => setTimeout(resolve, 200));
                                        
                                        // Tentar ler novamente
                                        const value = await executeGattOperation(async () => {
                                            return await bastaoCharacteristic.readValue();
                                        });
                                        
                                        errorCount = 0;
                                        handleBastaoValueChanged({ target: { value } });
                                    } else {
                                        throw new Error('Característica não suporta escrita');
                                    }
                                } catch (altError) {
                                    // Se o método alternativo também falhar, incrementar contador de erros
                                    errorCount++;
                                    console.error('Método alternativo falhou:', altError);
                                    
                                    // Se excedeu o limite de erros, tentar reconectar completamente
                                    if (errorCount >= MAX_ERRORS) {
                                        console.warn(`Excedido limite de ${MAX_ERRORS} erros consecutivos, reconectando...`);
                                        try {
                                            // Desconectar e reconectar completamente
                                            if (bastaoDevice && bastaoDevice.gatt) {
                                                if (bastaoDevice.gatt.connected) {
                                                    await bastaoDevice.gatt.disconnect();
                                                }
                                                await new Promise(resolve => setTimeout(resolve, 1000));
                                                await conectarBastao(); // Reconectar usando a função completa
                                                errorCount = 0;
                                            }
                                        } catch (reconnectError) {
                                            console.error('Falha na reconexão completa:', reconnectError);
                                        }
                                    }
                                }
                            } else {
                                // Outros erros
                                console.error('Erro ao ler valor do bastão:', readError);
                                console.log('Tipo de erro:', readError.name);
                                console.log('Mensagem de erro:', readError.message);
                                
                                errorCount++;
                                
                                // Tratamento específico para diferentes tipos de erros
                                if (readError.message.includes('GATT operation already in progress')) {
                                    console.warn('Erro de operação GATT em andamento, será tratado pela fila');
                                } else if (readError.name === 'NetworkError') {
                                    console.warn('Erro de rede detectado');
                                }
                                
                                // Se excedeu o limite de erros, tentar reconectar
                                if (errorCount >= MAX_ERRORS) {
                                    console.warn(`Excedido limite de ${MAX_ERRORS} erros consecutivos, reconectando...`);
                                    try {
                                        await conectarBastao(); // Reconectar usando a função completa
                                        errorCount = 0;
                                    } catch (reconnectError) {
                                        console.error('Falha na reconexão completa:', reconnectError);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        // Erro geral no bloco principal
                        console.error('Erro geral na leitura do bastão:', error);
                        errorCount++;
                    }
                }, 1000); // Mantido em 1000ms para evitar sobrecarga de operações GATT
            } else {
                throw new Error('A característica não suporta notificações nem leitura');
            }
            
            // Tentar fazer uma leitura inicial para ver se o dispositivo responde
            // Mas com um pequeno delay para evitar colisão com outras operações GATT
            // Atrasar a leitura inicial para dar tempo ao dispositivo de se estabilizar
            setTimeout(async () => {
                if (bastaoCharacteristic.properties.read) {
                    try {
                        console.log('Tentando leitura inicial...');
                        
                        // Verificar se o dispositivo ainda está conectado
                        if (!bastaoDevice || !bastaoDevice.gatt || !bastaoDevice.gatt.connected) {
                            console.warn('Dispositivo desconectado antes da leitura inicial, tentando reconectar...');
                            try {
                                if (bastaoDevice) {
                                    await bastaoDevice.gatt.connect();
                                    console.log('Reconectado com sucesso antes da leitura inicial');
                                }
                            } catch (reconnectError) {
                                console.error('Falha na reconexão antes da leitura inicial:', reconnectError);
                                return; // Sair e deixar o intervalo regular tentar depois
                            }
                        }
                        
                        // Tentar diferentes abordagens para a leitura inicial
                        try {
                            // 1. Primeiro, tentar leitura normal
                            const value = await executeGattOperation(async () => {
                                return await bastaoCharacteristic.readValue();
                            });
                            console.log('Leitura inicial bem-sucedida:', Array.from(new Uint8Array(value.buffer)));
                            handleBastaoValueChanged({ target: { value } });
                        } catch (readError) {
                            console.error('Erro na primeira tentativa de leitura inicial:', readError);
                            
                            // 2. Se falhar, tentar com um comando de escrita primeiro (se suportado)
                            if (bastaoCharacteristic.properties.write || 
                                bastaoCharacteristic.properties.writeWithoutResponse) {
                                
                                try {
                                    console.log('Tentando método alternativo com escrita...');
                                    
                                    // Comando genérico para solicitar dados (0x01)
                                    const cmd = new Uint8Array([0x01]);
                                    
                                    // Escrever comando
                                    if (bastaoCharacteristic.properties.write) {
                                        await executeGattOperation(async () => {
                                            return await bastaoCharacteristic.writeValue(cmd);
                                        });
                                    } else {
                                        await executeGattOperation(async () => {
                                            return await bastaoCharacteristic.writeValueWithoutResponse(cmd);
                                        });
                                    }
                                    
                                    // Pequeno delay antes de ler
                                    await new Promise(resolve => setTimeout(resolve, 300));
                                    
                                    // Tentar ler novamente
                                    const value = await executeGattOperation(async () => {
                                        return await bastaoCharacteristic.readValue();
                                    });
                                    
                                    console.log('Leitura inicial após escrita bem-sucedida:', 
                                        Array.from(new Uint8Array(value.buffer)));
                                    handleBastaoValueChanged({ target: { value } });
                                } catch (writeReadError) {
                                    console.error('Erro no método alternativo com escrita:', writeReadError);
                                    
                                    // 3. Última tentativa: apenas aguardar mais tempo e tentar novamente
                                    setTimeout(async () => {
                                        try {
                                            console.log('Fazendo última tentativa de leitura inicial após delay maior...');
                                            const value = await executeGattOperation(async () => {
                                                return await bastaoCharacteristic.readValue();
                                            });
                                            console.log('Terceira tentativa de leitura bem-sucedida:', 
                                                Array.from(new Uint8Array(value.buffer)));
                                            handleBastaoValueChanged({ target: { value } });
                                        } catch (thirdError) {
                                            console.error('Todas as tentativas de leitura inicial falharam:', thirdError);
                                            // Deixar o intervalo regular tentar depois
                                        }
                                    }, 1500); // Delay ainda maior para a terceira tentativa
                                }
                            } else {
                                // Se não suporta escrita, apenas tentar novamente com delay maior
                                setTimeout(async () => {
                                    try {
                                        console.log('Segunda tentativa de leitura inicial após delay maior...');
                                        const value = await executeGattOperation(async () => {
                                            return await bastaoCharacteristic.readValue();
                                        });
                                        console.log('Segunda tentativa de leitura bem-sucedida:', 
                                            Array.from(new Uint8Array(value.buffer)));
                                        handleBastaoValueChanged({ target: { value } });
                                    } catch (secondError) {
                                        console.error('Segunda tentativa de leitura falhou:', secondError);
                                        // Deixar o intervalo regular tentar depois
                                    }
                                }, 1200); // Delay maior para a segunda tentativa
                            }
                        }
                    } catch (error) {
                        console.error('Erro geral na leitura inicial:', error);
                        // Deixar o intervalo regular tentar depois
                    }
                }
            }, 1000); // Aumentado para 1000ms para dar mais tempo ao dispositivo
            
            bastaoStatusDiv.textContent = "Conectado a " + bastaoDevice.name;
            mostrarNotificacao("Bastão conectado com sucesso!", "success");
            
        } catch (error) {
            console.error('Erro ao conectar ao bastão:', error);
            const bastaoStatusDiv = document.getElementById('bastaoStatus');
            bastaoStatusDiv.textContent = "Erro: " + error.message;
            const conectarBastaoBtn = document.getElementById('conectarBastao');
            conectarBastaoBtn.classList.remove('connected');
            conectarBastaoBtn.classList.add('error');
            
            // Limpar recursos
            if (bastaoReadInterval) {
                clearInterval(bastaoReadInterval);
                bastaoReadInterval = null;
            }
            
            setTimeout(() => {
                conectarBastaoBtn.classList.remove('error');
            }, 3000);
            
            mostrarNotificacao("Erro ao conectar ao bastão: " + error.message, "error");
        }
    }

    // Função para conectar à balança
    async function conectarBalanca() {
        try {
            const balancaStatusDiv = document.getElementById('balancaStatus');
            balancaStatusDiv.textContent = "Procurando balança...";
            
            // Solicitar dispositivo Bluetooth com opções mais abrangentes
            balancaDevice = await navigator.bluetooth.requestDevice({
                // Primeiro tenta filtrar pelo nome específico da balança
                filters: [
                    { namePrefix: 'BT' }
                ],
                // Se não encontrar, aceita qualquer dispositivo
                optionalServices: ['6e400001-b5a3-f393-e0a9-e50e24dcca9e', 'battery_service', '0000180a-0000-1000-8000-00805f9b34fb', 'device_information']
            });
            
            balancaStatusDiv.textContent = "Conectando à balança...";
            const conectarBalancaBtn = document.getElementById('conectarBalanca');
            conectarBalancaBtn.classList.add('connected');
            
            // Adicionar listener para desconexão
            balancaDevice.addEventListener('gattserverdisconnected', onBalancaDisconnected);
            
            // Conectar ao GATT server
            const server = await balancaDevice.gatt.connect();
            
            // Obter todos os serviços disponíveis
            const services = await executeGattOperation(async () => {
                return await server.getPrimaryServices();
            });
            
            console.log('Serviços disponíveis na balança:', services.map(s => s.uuid));
            
            if (services.length === 0) {
                throw new Error('Nenhum serviço disponível na balança');
            }
            
            // Tentar obter serviço UART primeiro
            let service = null;
            try {
                service = await executeGattOperation(async () => {
                    return await server.getPrimaryService('6e400001-b5a3-f393-e0a9-e50e24dcca9e');
                });
                console.log('Serviço UART encontrado na balança');
            } catch (e) {
                // Se não encontrar, tente outros serviços conhecidos
                for (const serviceUuid of ['0000180a-0000-1000-8000-00805f9b34fb', 'device_information']) {
                    try {
                        service = await executeGattOperation(async () => {
                            return await server.getPrimaryService(serviceUuid);
                        });
                        console.log('Usando serviço alternativo na balança:', serviceUuid);
                        break;
                    } catch (err) {
                        console.log('Serviço não encontrado na balança:', serviceUuid);
                    }
                }
                
                // Se ainda não encontrou, use o primeiro serviço disponível
                if (!service && services.length > 0) {
                    service = services[0];
                    console.log('Usando primeiro serviço disponível na balança:', service.uuid);
                }
            }
            
            if (!service) {
                throw new Error('Não foi possível obter um serviço utilizável na balança');
            }
            
            // Obter todas as características disponíveis
            const characteristics = await executeGattOperation(async () => {
                return await service.getCharacteristics();
            });
            
            console.log('Características disponíveis na balança:', characteristics.map(c => ({
                uuid: c.uuid,
                properties: {
                    read: c.properties.read,
                    write: c.properties.write,
                    notify: c.properties.notify,
                    indicate: c.properties.indicate
                }
            })));
            
            if (characteristics.length === 0) {
                throw new Error('Nenhuma característica disponível no serviço da balança');
            }
            
            // Tentar encontrar uma característica que suporte notificações primeiro
            balancaCharacteristic = null;
            
            // Procurar por características UART RX primeiro
            try {
                balancaCharacteristic = await executeGattOperation(async () => {
                    return await service.getCharacteristic('6e400003-b5a3-f393-e0a9-e50e24dcca9e');
                });
                console.log('Característica UART RX encontrada na balança');
            } catch (e) {
                // Procurar por qualquer característica que suporte notificações
                const notifyCharacteristics = characteristics.filter(
                    char => char.properties.notify || char.properties.indicate
                );
                
                if (notifyCharacteristics.length > 0) {
                    balancaCharacteristic = notifyCharacteristics[0];
                    console.log('Usando característica com notificação na balança:', balancaCharacteristic.uuid);
                } else {
                    // Se não houver características com notificação, use uma que suporte leitura
                    const readableCharacteristics = characteristics.filter(
                        char => char.properties.read
                    );
                    
                    if (readableCharacteristics.length > 0) {
                        balancaCharacteristic = readableCharacteristics[0];
                        console.log('Usando característica com leitura na balança:', balancaCharacteristic.uuid);
                    } else if (characteristics.length > 0) {
                        balancaCharacteristic = characteristics[0];
                        console.log('Usando primeira característica disponível na balança:', balancaCharacteristic.uuid);
                    }
                }
            }
            
            if (!balancaCharacteristic) {
                throw new Error('Não foi possível obter uma característica utilizável na balança');
            }
            
            // Configurar o modo de leitura baseado nas propriedades da característica
            if (balancaCharacteristic.properties.notify) {
                // Modo de notificação
                await executeGattOperation(async () => {
                    await balancaCharacteristic.startNotifications();
                });
                
                balancaNotificationsStarted = true;
                balancaCharacteristic.addEventListener('characteristicvaluechanged', handleBalancaValueChanged);
                console.log('Modo de notificação ativado na balança');
                
                // Limpar qualquer intervalo de leitura existente
                if (balancaReadInterval) {
                    clearInterval(balancaReadInterval);
                    balancaReadInterval = null;
                }
            } else if (balancaCharacteristic.properties.read) {
                // Modo de leitura periódica
                balancaNotificationsStarted = false;
                console.log('Modo de leitura periódica ativado na balança');
                
                // Configurar leitura periódica a cada 500ms
                if (balancaReadInterval) {
                    clearInterval(balancaReadInterval);
                }
                
                balancaReadInterval = setInterval(async () => {
                    try {
                        const value = await executeGattOperation(async () => {
                            return await balancaCharacteristic.readValue();
                        });
                        handleBalancaValueChanged({ target: { value } });
                    } catch (error) {
                        console.error('Erro ao ler valor da balança:', error);
                        // Se houver erro na leitura, tente reconectar
                        if (error.message.includes('GATT operation failed')) {
                            clearInterval(balancaReadInterval);
                            balancaReadInterval = null;
                            onBalancaDisconnected();
                        }
                    }
                }, 500); // Mais frequente para a balança
            } else {
                throw new Error('A característica não suporta notificações nem leitura');
            }
            
            balancaStatusDiv.textContent = "Conectado a " + balancaDevice.name;
            mostrarNotificacao("Balança conectada com sucesso!");
            
            // Habilitar campo de peso
            pesoInput.disabled = false;
            
        } catch (error) {
            console.error('Erro ao conectar à balança:', error);
            const balancaStatusDiv = document.getElementById('balancaStatus');
            balancaStatusDiv.textContent = "Erro: " + error.message;
            const conectarBalancaBtn = document.getElementById('conectarBalanca');
            conectarBalancaBtn.classList.remove('connected');
            conectarBalancaBtn.classList.add('error');
            
            // Limpar recursos
            if (balancaReadInterval) {
                clearInterval(balancaReadInterval);
                balancaReadInterval = null;
            }
            
            setTimeout(() => {
                conectarBalancaBtn.classList.remove('error');
            }, 2000);
        }
    }
    
    // Função para tratar desconexão da balança
    function onBalancaDisconnected() {
        balancaNotificationsStarted = false;
        balancaCharacteristic = null;
        
        // Limpar intervalo de leitura se existir
        if (balancaReadInterval) {
            clearInterval(balancaReadInterval);
            balancaReadInterval = null;
        }
        
        const balancaStatusDiv = document.getElementById('balancaStatus');
        balancaStatusDiv.textContent = "Desconectado";
        const conectarBalancaBtn = document.getElementById('conectarBalanca');
        conectarBalancaBtn.classList.remove('connected');
        mostrarNotificacao("Balança desconectada");
        
        // Desabilitar campo de peso
        pesoInput.disabled = true;
    }
    
    // Função para processar dados recebidos da balança conforme documentação do fabricante
    function handleBalancaValueChanged(event) {
        const value = event.target.value;
        const decoder = new TextDecoder('utf-8');
        const frameRecebido = decoder.decode(value).trim();
        
        // Exibir dados brutos para depuração
        console.log('Dados brutos da balança:', Array.from(new Uint8Array(value.buffer)));
        console.log('Frame recebido da balança:', frameRecebido);
        
        // Atualizar o último frame recebido
        ultimoFrame = frameRecebido;
        
        // Verificar se é um frame de peso válido (formato: "PESO      0 N")
        if (frameRecebido.startsWith('PESO')) {
            // Extrair o peso e o status conforme documentação do fabricante
            // Formato: "PESO      0 N" onde N é o status
            // Status: A - aguarde (aguarde)
            //         N - nenhum (aguardando animal)
            //         P - pronto (autoriza congela peso)
            //         C - congelado (autoriza registrar o peso)
            //         R - registrado (registrado)
            
            // Extrair o peso (7 bytes após a palavra PESO)
            const pesoStr = frameRecebido.substring(4, 11).trim();
            // O status é o último caractere
            const statusBalanca = frameRecebido.charAt(frameRecebido.length - 1);
            
            // Converter para número
            const pesoAtual = parseFloat(pesoStr);
            
            // Atualizar status da balança
            let statusText = "";
            switch(statusBalanca) {
                case 'A': statusText = "Aguarde"; break;
                case 'N': statusText = "Aguardando animal"; break;
                case 'P': statusText = "Pronto para congelar"; break;
                case 'C': statusText = "Peso congelado"; break;
                case 'R': statusText = "Peso registrado"; break;
                default: statusText = "Status desconhecido"; break;
            }
            
            const balancaStatusDiv = document.getElementById('balancaStatus');
            balancaStatusDiv.textContent = `Status: ${statusText} (${pesoAtual} kg)`;
            
            // Atualizar a interface com base no status
            balancaStatusDiv.classList.remove('status-aguarde', 'status-pronto', 'status-congelado', 'status-registrado');
            if (statusBalanca === 'A') {
                balancaStatusDiv.classList.add('status-aguarde');
            } else if (statusBalanca === 'P') {
                balancaStatusDiv.classList.add('status-pronto');
            } else if (statusBalanca === 'C') {
                balancaStatusDiv.classList.add('status-congelado');
            } else if (statusBalanca === 'R') {
                balancaStatusDiv.classList.add('status-registrado');
            }
            
            // Se o status for 'C' (congelado) ou 'R' (registrado), atualizar o campo de peso
            if (statusBalanca === 'C' || statusBalanca === 'R') {
                pesoInput.value = pesoAtual;
                
                // Destacar visualmente que o peso foi capturado
                balancaStatusDiv.classList.add('peso-capturado');
                setTimeout(() => {
                    balancaStatusDiv.classList.remove('peso-capturado');
                }, 2000);
                
                // Calcular GMD
                calcularNovoGMD();
                
                // Se estiver no modo automação e o status for 'R', iniciar o processo de salvamento
                if (automationActive && statusBalanca === 'R') {
                    beep();
                    autoPesoTriggered = true;
                    animateSaveButton();
                    
                    // Habilitar os checkboxes se necessário
                    fazerManejoCheckbox.disabled = false;
                    fazerApartacaoCheckbox.disabled = false;
                    submitButton.disabled = false;
                }
            }
        }
    }

    // Event Listeners
    toggleAutomation.addEventListener('change', function() {
        automationActive = this.checked;
        beep();
        
        if (automationActive) {
            // Mostrar popup de instruções
            const popup = document.createElement('div');
            popup.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: #17a2b8;
                color: #fff;
                padding: 15px 30px;
                border-radius: 5px;
                z-index: 9999;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            `;
            popup.innerHTML = `
                <strong>Automação Ativada!</strong><br>
                1. Use o bastão para ler o brinco<br>
                2. Aguarde a balança enviar o peso<br>
                3. O sistema calculará o GMD automaticamente<br>
                4. O registro será salvo automaticamente
            `;
            document.body.appendChild(popup);
            
            setTimeout(() => popup.remove(), 5000);
            brincoInput.focus();
        }
    });

    brincoInput.addEventListener('input', function(e) {
        const brinco = e.target.value.trim();
        
        // Se o brinco tiver pelo menos 3 caracteres, usar um debounce para busca
        if (brinco.length >= 3) {
            // Limpar timeout anterior se existir
            if (window.brincoTimeout) {
                clearTimeout(window.brincoTimeout);
            }
            
            // Definir um novo timeout (300ms de delay)
            window.brincoTimeout = setTimeout(() => {
                buscarAnimal(brinco);
            }, 300);
        }
    });

    brincoInput.addEventListener('blur', function() {
        const brinco = this.value.trim();
        
        if (brinco) {
            buscarAnimal(brinco);
        }
    });

    pesoInput.addEventListener('input', function() {
        // Atualiza o GMD quando o peso for alterado
        calcularNovoGMD();
    });
    
    pesoInput.addEventListener('paste', function(e) {
        // Permitir um pequeno delay para o valor ser inserido
        setTimeout(() => {
            console.log("Valor colado no campo de peso:", this.value);
            calcularNovoGMD();
            
            if (automationActive && this.value.trim()) {
                console.log("Modo de automação ativo e peso inserido. Iniciando processo automático.");
                setTimeout(() => {
                    beep();
                    autoPesoTriggered = true;
                    animateSaveButton();
                }, 800);
            }
        }, 100);
    });

    fazerManejoCheckbox.addEventListener('change', function() {
        // Mostrar ou esconder campos de manejo sanitário com base no estado do checkbox
        manejoSanitarioCampos.style.display = this.checked ? 'block' : 'none';
    });

    fazerApartacaoCheckbox.addEventListener('change', function() {
        // Mostrar ou esconder campos de apartação com base no estado do checkbox
        apartacaoCampos.style.display = this.checked ? 'block' : 'none';
        
        if (this.checked && document.getElementById('fazenda_id').value) {
            carregarLotesPorFazenda(document.getElementById('fazenda_id').value);
            carregarPastosPorFazenda(document.getElementById('fazenda_id').value);
        }
    });

    form.addEventListener('submit', function(e) {
        e.preventDefault();
        if (!window.registroEmAndamento) {
            registrarManejo(new FormData(this));
        }
    });

    // Event listeners para botões Bluetooth
    const conectarBastaoBtn = document.getElementById('conectarBastao');
    const conectarBalancaBtn = document.getElementById('conectarBalanca');
    conectarBastaoBtn.addEventListener('click', conectarBastao);
    conectarBalancaBtn.addEventListener('click', conectarBalanca);

    // Inicializar campos
    pesoInput.disabled = true;
    fazerManejoCheckbox.disabled = true;
    fazerApartacaoCheckbox.disabled = true;
    submitButton.disabled = true;
    document.getElementById('animalInfo').style.display = 'none';
    manejoSanitarioCampos.style.display = 'none';
    apartacaoCampos.style.display = 'none';
});

// Função para tratar desconexão do bastão
function onBastaoDisconnected() {
    bastaoNotificationsStarted = false;
    bastaoCharacteristic = null;
    
    // Limpar intervalo de leitura se existir
    if (bastaoReadInterval) {
        clearInterval(bastaoReadInterval);
        bastaoReadInterval = null;
    }
    
    const bastaoStatusDiv = document.getElementById('bastaoStatus');
    bastaoStatusDiv.textContent = "Desconectado";
    const conectarBastaoBtn = document.getElementById('conectarBastao');
    conectarBastaoBtn.classList.remove('connected');
    mostrarNotificacao("Bastão desconectado");
}

// Função para processar dados recebidos do bastão
function handleBastaoValueChanged(event) {
    const value = event.target.value;
    
    // Exibir os dados brutos recebidos para depuração
    console.log('Dados brutos recebidos do bastão:', Array.from(new Uint8Array(value.buffer)).map(b => b.toString(16).padStart(2, '0')).join(' '));
    
    // Tentar diferentes decodificações
    const decoder = new TextDecoder('utf-8');
    let brincoLido = decoder.decode(value).trim();
    
    // Se o brinco estiver vazio ou contiver apenas caracteres nulos, tente outras abordagens
    if (!brincoLido || /^[\x00\s]*$/.test(brincoLido)) {
        // Tentar extrair caracteres ASCII válidos
        const bytes = new Uint8Array(value.buffer);
        const asciiChars = [];
        
        for (let i = 0; i < bytes.length; i++) {
            // Considerar apenas caracteres ASCII imprimíveis (32-126)
            if (bytes[i] >= 32 && bytes[i] <= 126) {
                asciiChars.push(String.fromCharCode(bytes[i]));
            }
        }
        
        if (asciiChars.length > 0) {
            brincoLido = asciiChars.join('');
            console.log('Brinco extraído de caracteres ASCII:', brincoLido);
        }
        
        // Se ainda estiver vazio, tente interpretar como número
        if (!brincoLido || /^[\x00\s]*$/.test(brincoLido)) {
            // Tentar interpretar como número (big-endian e little-endian)
            if (bytes.length >= 4) {
                const view = new DataView(value.buffer);
                const numBE = view.getUint32(0, false); // Big Endian
                const numLE = view.getUint32(0, true);  // Little Endian
                
                console.log('Possíveis interpretações numéricas:', {
                    bigEndian: numBE,
                    littleEndian: numLE
                });
                
                // Usar o número se for razoável (não zero e não muito grande)
                if (numBE > 0 && numBE < 1000000000) {
                    brincoLido = numBE.toString();
                    console.log('Usando interpretação numérica (BE):', brincoLido);
                } else if (numLE > 0 && numLE < 1000000000) {
                    brincoLido = numLE.toString();
                    console.log('Usando interpretação numérica (LE):', brincoLido);
                }
            }
        }
    }
    
    console.log('Brinco lido após processamento:', brincoLido);
    
    // Verificar se o brinco é válido (não vazio e não contém apenas caracteres nulos)
    const brincoValido = brincoLido && 
                        !/^[\x00\s]*$/.test(brincoLido) && // Não contém apenas nulos ou espaços
                        brincoLido.length > 1 && // Tem pelo menos 2 caracteres
                        brincoLido.length < 30; // Não é muito longo (provavelmente erro)
    
    // Verificar se já passou tempo suficiente desde a última leitura (500ms)
    const agora = Date.now();
    const tempoSuficiente = (agora - ultimaLeituraBrinco) > 500;
    
    // Verificar se é diferente do último brinco lido
    const brincoNovo = brincoLido !== ultimoBrincoLido;
    
    console.log('Dados recebidos do bastão:', {
        bruto: brincoLido,
        valido: brincoValido,
        novo: brincoNovo,
        tempoSuficiente: tempoSuficiente
    });
    
    // Só processa se for um brinco válido, novo e tiver passado tempo suficiente
    if (brincoValido && (brincoNovo || tempoSuficiente)) {
        console.log('Brinco válido lido:', brincoLido);
        
        // Atualizar variáveis de controle
        ultimoBrincoLido = brincoLido;
        ultimaLeituraBrinco = agora;
        
        // Preencher o campo de brinco
        brincoInput.value = brincoLido;
        
        // Disparar evento de busca de animal
        buscarAnimal(brincoLido);
        
        // Reproduzir beep de confirmação
        beep();
        
        // Focar no próximo campo se automação estiver ativa
        if (automationActive) {
            pesoInput.focus();
        }
        
        // Mostrar notificação
        mostrarNotificacao("Brinco lido: " + brincoLido, "success");
    }
}
</script>
{% endblock %}