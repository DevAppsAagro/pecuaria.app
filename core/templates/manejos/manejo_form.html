{% extends 'base.html' %}

{% block content %}
<style>
    /* Estilos para melhor visualização no curral */
    body {
        background-color: #f8f9fa;
    }
    
    .form-control {
        font-size: 1.1rem;  
        padding: 0.5rem;    
        border: 2px solid #333;
        height: auto;
    }
    
    .form-label {
        font-size: 1rem;    
        font-weight: bold;
        color: #333;
        margin-bottom: 0.3rem;
    }
    
    .btn-manejo {
        font-size: 1.1rem;  
        padding: 0.6rem 1.2rem; 
        margin: 0.3rem;     
    }
    
    .card {
        border: 2px solid #333;
        margin-bottom: 0.6rem; 
    }
    
    .card-header {
        background-color: #333;
        color: white;
        padding: 0.6rem;    
    }

    .card-header h3 {
        font-size: 1.1rem;  
        margin: 0;
    }
    
    .info-box {
        background-color: #fff;
        border: 1px solid #333; 
        padding: 0.6rem;    
        margin-bottom: 0.6rem; 
    }
    
    .info-text {
        font-size: 0.9rem;  
        margin-bottom: 0.3rem; 
    }
    
    .checkbox-lg {
        width: 18px;       
        height: 18px;      
        margin-right: 6px; 
    }
    
    .checkbox-label {
        font-size: 1rem;   
        font-weight: bold;
    }
    
    .section-divider {
        border-left: 1px solid #333; 
        height: 100%;
        padding-left: 0.6rem; 
    }

    .mb-3 {
        margin-bottom: 0.6rem !important; 
    }

    .p-4 {
        padding: 0.8rem !important; 
    }

    h4 {
        font-size: 1rem;   
        margin-bottom: 0.6rem; 
    }

    h5 {
        font-size: 0.9rem; 
        margin-bottom: 0.4rem; 
    }
    
    /* GMD box mais compacto */
    .alert-info {
        padding: 0.5rem;
        margin-top: 0.5rem !important;
        margin-bottom: 0.5rem !important;
    }
    
    /* Botão de salvar sempre visível */
    .action-buttons {
        position: fixed;
        bottom: 0;
        right: 0;
        background: #f8f9fa;
        padding: 10px;
        border-top: 1px solid #ddd;
        border-left: 1px solid #ddd;
        z-index: 1000;
    }
    
    /* Adicionar padding no final do formulário para dar espaço ao botão fixo */
    .container-fluid {
        padding-bottom: 60px;
    }
    
    /* Notificação temporária */
    .notification {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 25px;
        background-color: #28a745;
        color: white;
        border-radius: 5px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        z-index: 9999;
        font-size: 1.1rem;
        font-weight: bold;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
    }
    
    .notification.show {
        opacity: 1;
    }
    
    /* Estilos para os botões de Bluetooth */
    .bluetooth-btn {
        font-size: 0.9rem;
        padding: 0.3rem 0.6rem;
        margin-left: 0.3rem;
        background-color: #0d6efd;
        color: white;
        border: none;
        border-radius: 4px;
    }
    
    .bluetooth-btn.connected {
        background-color: #198754;
    }
    
    .bluetooth-btn.error {
        background-color: #dc3545;
    }
    
    .bluetooth-status {
        font-size: 0.8rem;
        margin-top: 0.2rem;
        color: #6c757d;
    }
    
    .input-group-append {
        display: flex;
    }
    
    /* Estilos para notificações */
    .notificacao {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 10px 15px;
        background-color: #f8f9fa;
        border-left: 4px solid #007bff;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        border-radius: 4px;
        z-index: 9999;
        opacity: 0;
        transform: translateY(20px);
        transition: opacity 0.3s, transform 0.3s;
        font-size: 14px;
        max-width: 300px;
    }
    
    .notificacao.visivel {
        opacity: 1;
        transform: translateY(0);
    }
    
    .notificacao.info {
        border-left-color: #007bff;
    }
    
    .notificacao.success {
        border-left-color: #28a745;
    }
    
    .notificacao.warning {
        border-left-color: #ffc107;
    }
    
    .notificacao.error {
        border-left-color: #dc3545;
    }
    
    /* Estilos para o modo de campo */
    .field-mode {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .field-mode .form-group {
        margin-bottom: 5px;
    }
    
    .field-mode label {
        font-weight: bold;
        margin-bottom: 2px;
    }
    
    .field-mode input, .field-mode select {
        padding: 8px;
        font-size: 16px;
    }
    
    /* Estilos para os botões de conexão Bluetooth */
    .bt-connect-btn {
        padding: 8px 15px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }
    
    .bt-connect-btn.connected {
        background-color: #28a745;
    }
    
    .bt-connect-btn.error {
        background-color: #dc3545;
    }
    
    .bt-status {
        padding: 8px;
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-bottom: 15px;
    }
    
    /* Estilos para status da balança */
    .bt-status.status-aguarde {
        background-color: #fff3cd;
        border-color: #ffeeba;
        color: #856404;
    }
    
    .bt-status.status-pronto {
        background-color: #d4edda;
        border-color: #c3e6cb;
        color: #155724;
    }
    
    .bt-status.status-congelado {
        background-color: #cce5ff;
        border-color: #b8daff;
        color: #004085;
    }
    
    .bt-status.status-registrado {
        background-color: #d1ecf1;
        border-color: #bee5eb;
        color: #0c5460;
    }
    
    .bt-status.peso-capturado {
        animation: highlight-peso 2s;
    }
    
    @keyframes highlight-peso {
        0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
        100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
    }
    
    /* Estilos para notificações */
    .notificacao {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 10px 15px;
        background-color: #007bff;
        color: white;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        z-index: 1000;
        opacity: 0;
        transform: translateY(-20px);
        transition: opacity 0.3s, transform 0.3s;
    }
    
    .notificacao.visivel {
        opacity: 1;
        transform: translateY(0);
    }
    
    .notificacao.success {
        background-color: #28a745;
    }
    
    .notificacao.error {
        background-color: #dc3545;
    }
    
    .notificacao.warning {
        background-color: #ffc107;
        color: #212529;
    }
    
    /* Estilos para o botão de salvar */
    .save-button-container {
        margin-top: 20px;
        text-align: center;
    }
    
    .save-button {
        padding: 10px 20px;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 16px;
        cursor: pointer;
    }
    
    .save-button:disabled {
        background-color: #6c757d;
        cursor: not-allowed;
    }
    
    .save-button.pulse {
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.05);
            background-color: #218838;
        }
        100% {
            transform: scale(1);
        }
    }
    
    /* Estilos para o modo de automação */
    .automation-toggle {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
    }
    
    .automation-toggle input {
        margin-right: 8px;
    }
    
    .automation-active {
        background-color: #f8f9fa;
        padding: 10px;
        border: 1px solid #28a745;
        border-radius: 4px;
    }
</style>

<!-- Div para notificações temporárias -->
<div id="notification" class="notification"></div>

<div class="container-fluid p-4" style="height: calc(100vh - 100px);">
    <form method="post" id="manejoForm" action="{% url 'manejo_create' %}">
        {% csrf_token %}
        
        <!-- Campos ocultos para armazenar IDs -->
        <input type="hidden" id="animal_id" name="animal_id">
        <input type="hidden" id="lote_id" name="lote_id">
        <input type="hidden" id="pasto_id" name="pasto_id">
        <input type="hidden" id="fazenda_id" name="fazenda_id">
        
        <div class="row h-100">
            <!-- Coluna da Esquerda - Informações do Animal -->
            <div class="col-md-4">
                <div class="card h-100">
                    <div class="card-header">
                        <h3><i class="fas fa-cow me-2"></i>Identificação do Animal</h3>
                    </div>
                    <div class="card-body">
                        <!-- Data do Manejo -->
                        <div class="mb-2">
                            <label for="data" class="form-label">
                                <i class="fas fa-calendar me-2"></i>Data
                            </label>
                            <input type="date" class="form-control" id="data" name="data" required value="{% now 'Y-m-d' %}">
                        </div>

                        <!-- Brinco com botão de conexão Bluetooth -->
                        <div class="mb-2">
                            <label for="brinco" class="form-label">
                                <i class="fas fa-tag me-2"></i>Brinco
                            </label>
                            <div class="input-group">
                                <input type="text" class="form-control" id="brinco" name="brinco" 
                                       placeholder="Digite o brinco" required>
                                <div class="input-group-append">
                                    <button type="button" id="conectarBastao" class="bluetooth-btn" title="Conectar bastão">
                                        <i class="fas fa-bluetooth-b"></i>
                                    </button>
                                </div>
                            </div>
                            <div id="bastaoStatus" class="bluetooth-status"></div>
                        </div>

                        <!-- Informações do Animal -->
                        <div id="animalInfo" class="info-box" style="display: none;">
                            <h4><i class="fas fa-info-circle me-2"></i>Informações</h4>
                            <div id="animalDetails">
                                <p class="info-text"><strong>Brinco:</strong> <span id="animalBrinco"></span></p>
                                <p class="info-text"><strong>Raça:</strong> <span id="animalRaca"></span></p>
                                <p class="info-text"><strong>Categoria:</strong> <span id="animalCategoria"></span></p>
                                <p class="info-text"><strong>Lote:</strong> <span id="animalLote"></span></p>
                                <p class="info-text"><strong>Pasto:</strong> <span id="animalPasto"></span></p>
                            </div>
                            
                            <div id="ultimaPesagem" class="mt-2" style="display: none;">
                                <h4><i class="fas fa-weight me-2"></i>Histórico de Peso</h4>
                                <p class="info-text"><strong>Último Peso:</strong> <span id="ultimoPeso"></span> kg</p>
                                <p class="info-text"><strong>Data:</strong> <span id="ultimaData"></span></p>
                            </div>

                            <div id="gmdInfo" class="alert alert-info mt-2" style="display: none;">
                                <p class="info-text mb-0">
                                    <strong>GMD Atual:</strong> <span id="gmdValor"></span> kg/dia
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Coluna da Direita - Manejos -->
            <div class="col-md-8">
                <div class="row h-100">
                    <!-- Pesagem e Apartação -->
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header">
                                <h3><i class="fas fa-weight me-2"></i>Pesagem e Apartação</h3>
                            </div>
                            <div class="card-body">
                                <!-- Tipo de Manejo -->
                                <div class="mb-2">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="form-check me-3">
                                            <input class="form-check-input checkbox-lg" type="checkbox" id="manejo_desmame" name="manejo_desmame">
                                            <label class="form-check-label checkbox-label" for="manejo_desmame">
                                                <i class="fas fa-baby me-1"></i>Desmame
                                            </label>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Peso com botão de conexão Bluetooth -->
                                <div class="mb-2">
                                    <label for="peso" class="form-label">Peso (kg)</label>
                                    <div class="input-group">
                                        <input type="number" class="form-control" id="peso" name="peso" step="0.01" disabled>
                                        <div class="input-group-append">
                                            <button type="button" id="conectarBalanca" class="bluetooth-btn" title="Conectar balança">
                                                <i class="fas fa-bluetooth-b"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div id="balancaStatus" class="bluetooth-status"></div>
                                </div>
                                <div id="novoGMDInfo" class="alert alert-info mt-2" style="display: none;">
                                    <p class="info-text mb-0">
                                        <strong>Novo GMD:</strong> <span id="novoGMDValor"></span> kg/dia
                                    </p>
                                </div>

                                <!-- Apartação -->
                                <div class="form-check mb-2">
                                    <input class="form-check-input checkbox-lg" type="checkbox" id="fazer_apartacao" name="fazer_apartacao" disabled>
                                    <label class="form-check-label checkbox-label" for="fazer_apartacao">
                                        Fazer Apartação
                                    </label>
                                </div>

                                <div id="apartacao_campos" style="display: none;">
                                    <div class="mb-2">
                                        <label for="peso_referencia" class="form-label">Peso de Referência (kg)</label>
                                        <input type="number" class="form-control" id="peso_referencia" name="peso_referencia" step="0.01">
                                    </div>

                                    <div class="row">
                                        <div class="col-md-6">
                                            <h5>Acima do Peso</h5>
                                            <div class="mb-2">
                                                <label for="lote_acima" class="form-label">Lote</label>
                                                <select class="form-control" id="lote_acima" name="lote_acima">
                                                    <option value="">Selecione</option>
                                                </select>
                                            </div>
                                            <div class="mb-2">
                                                <label for="pasto_acima" class="form-label">Pasto</label>
                                                <select class="form-control" id="pasto_acima" name="pasto_acima">
                                                    <option value="">Selecione</option>
                                                </select>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <h5>Abaixo do Peso</h5>
                                            <div class="mb-2">
                                                <label for="lote_abaixo" class="form-label">Lote</label>
                                                <select class="form-control" id="lote_abaixo" name="lote_abaixo">
                                                    <option value="">Selecione</option>
                                                </select>
                                            </div>
                                            <div class="mb-2">
                                                <label for="pasto_abaixo" class="form-label">Pasto</label>
                                                <select class="form-control" id="pasto_abaixo" name="pasto_abaixo">
                                                    <option value="">Selecione</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Manejo Sanitário -->
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header">
                                <h3><i class="fas fa-syringe me-2"></i>Manejo Sanitário</h3>
                            </div>
                            <div class="card-body">
                                <div class="form-check mb-2">
                                    <input class="form-check-input checkbox-lg" type="checkbox" id="fazer_manejo" name="fazer_manejo" disabled>
                                    <label class="form-check-label checkbox-label" for="fazer_manejo">
                                        Fazer Manejo Sanitário
                                    </label>
                                </div>

                                <div id="manejo_sanitario_campos" style="display: none;">
                                    <div class="mb-2">
                                        <label for="insumo" class="form-label">Insumo</label>
                                        <input type="text" class="form-control" id="insumo" name="insumo">
                                    </div>

                                    <div class="mb-2">
                                        <label for="tipo_manejo" class="form-label">Tipo de Manejo</label>
                                        <input type="text" class="form-control" id="tipo_manejo" name="tipo_manejo">
                                    </div>

                                    <div class="mb-2">
                                        <label for="dias_proximo" class="form-label">Dias p/ Próximo</label>
                                        <input type="number" class="form-control" id="dias_proximo" name="dias_proximo">
                                    </div>

                                    <div class="mb-2">
                                        <label for="observacao" class="form-label">Observação</label>
                                        <textarea class="form-control" id="observacao" name="observacao" rows="2"></textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Botões fixos no rodapé -->
        <div class="position-fixed bottom-0 start-0 w-100 bg-light p-2" style="border-top: 1px solid #ddd; z-index: 1000;">
            <div class="d-flex justify-content-center gap-2 align-items-center">
                <label for="toggleAutomation" class="form-label mb-0 me-1">Automação</label>
                <label class="switch">
                    <input type="checkbox" id="toggleAutomation">
                    <span class="slider round"></span>
                </label>
                <button type="submit" id="submitButton" class="btn btn-primary btn-sm ms-2" disabled>
                    <i class="fas fa-save me-1"></i><span class="button-text">Salvar</span>
                </button>
                <button type="reset" class="btn btn-secondary btn-sm">
                    <i class="fas fa-undo me-1"></i>Limpar
                </button>
                <style>
                .switch {
                    position: relative;
                    display: inline-block;
                    width: 50px;
                    height: 28px;
                }

                .switch input { 
                    opacity: 0;
                    width: 0;
                    height: 0;
                }

                .slider {
                    position: absolute;
                    cursor: pointer;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background-color: #ccc;
                    transition: .4s;
                }

                .slider:before {
                    position: absolute;
                    content: "";
                    height: 20px;
                    width: 20px;
                    left: 4px;
                    bottom: 4px;
                    background-color: white;
                    transition: .4s;
                }

                input:checked + .slider {
                    background-color: #2196F3;
                }

                input:checked + .slider:before {
                    transform: translateX(22px);
                }

                /* Rounded sliders */
                .slider.round {
                    border-radius: 28px;
                }

                .slider.round:before {
                    border-radius: 50%;
                }
                
                /* Estilos para as notificações */
                .notificacao {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 4px;
                    color: white;
                    font-weight: 500;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                    z-index: 9999;
                    opacity: 0;
                    transform: translateY(20px);
                    transition: opacity 0.3s, transform 0.3s;
                    max-width: 300px;
                }
                
                .notificacao.visivel {
                    opacity: 1;
                    transform: translateY(0);
                }
                
                .notificacao.info {
                    background-color: #3498db;
                }
                
                .notificacao.success {
                    background-color: #2ecc71;
                }
                
                .notificacao.warning {
                    background-color: #f39c12;
                }
                
                .notificacao.error {
                    background-color: #e74c3c;
                }
                </style>
            </div>
        </div>
    </form>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Variáveis globais para o Bluetooth
// Bastão
var bastaoDevice = null;
var bastaoCharacteristic = null;
var bastaoNotificationsStarted = false;
var bastaoReadInterval = null;
var ultimoBrincoLido = '';
var ultimaLeituraBrinco = 0;

// Balança
var balancaDevice = null;
var balancaCharacteristic = null;
var balancaNotificationsStarted = false;
var balancaReadInterval = null;
var ultimoPesoLido = 0;
var ultimaLeituraBalanca = 0;

// Controle de erros
var errorCount = 0;

// Função para mostrar notificações temporárias
function mostrarNotificacao(mensagem, tipo = 'info', duracao = 3000) {
    // Criar elemento de notificação
    const notificacao = document.createElement('div');
    notificacao.className = `notificacao ${tipo}`;
    notificacao.textContent = mensagem;
    
    // Adicionar ao corpo do documento
    document.body.appendChild(notificacao);
    
    // Mostrar com animação
    setTimeout(() => {
        notificacao.classList.add('visivel');
    }, 10);
    
    // Remover após a duração especificada
    setTimeout(() => {
        notificacao.classList.remove('visivel');
        setTimeout(() => {
            document.body.removeChild(notificacao);
        }, 300); // Tempo da animação de saída
    }, duracao);
}

// Fila para operações GATT
let gattOperationQueue = [];
let gattOperationInProgress = false;
let bastaoErrorCount = 0;
let balancaErrorCount = 0;
let consecutiveErrors = 0;
let lastErrorTime = 0;
const MAX_CONSECUTIVE_GATT_ERRORS = 5;

async function executeGattOperation(operation) {
    return new Promise((resolve, reject) => {
        gattOperationQueue.push({
            operation: operation,
            resolve: resolve,
            reject: reject,
            retryCount: 0,
            maxRetries: 5,
            initialBackoff: 150,
            currentBackoff: 150
        });
        if (!gattOperationInProgress) {
            processGattQueue();
        }
    });
}

// Função para processar a fila de operações GATT
async function processGattQueue() {
    if (gattOperationQueue.length === 0) {
        gattOperationInProgress = false;
        return;
    }
    
    gattOperationInProgress = true;
    const nextOperation = gattOperationQueue.shift();
    
    // Verificar se houve muitos erros consecutivos e pausar brevemente
    const now = Date.now();
    if (consecutiveErrors > 10 && now - lastErrorTime < 5000) {
        console.log('Muitos erros consecutivos, pausando a fila por 2 segundos...');
        setTimeout(() => {
            consecutiveErrors = 0;
            gattOperationQueue.unshift(nextOperation);
            processGattQueue();
        }, 2000);
        return;
    }
    
    try {
        const result = await nextOperation.operation();
        nextOperation.resolve(result);
        consecutiveErrors = 0; // Resetar contador de erros em caso de sucesso
    } catch (error) {
        console.error('Erro na operação GATT:', error);
        lastErrorTime = Date.now();
        consecutiveErrors++;
        
        // Tratar erros específicos
        if (error.name === 'NetworkError' && error.message.includes('GATT operation already in progress')) {
            // Para este erro específico, esperar mais tempo
            const delay = Math.min(500 * (nextOperation.retryCount + 1), 3000); // Máximo de 3 segundos
            console.log(`Erro GATT operation already in progress. Aguardando ${delay}ms...`);
            
            // Incrementar contador de tentativas e backoff
            nextOperation.retryCount++;
            
            // Colocar de volta na fila
            setTimeout(() => {
                gattOperationQueue.unshift(nextOperation);
                processGattQueue();
            }, delay);
            return;
        }
        
        // Verificar se deve tentar novamente
        if (nextOperation.retryCount < nextOperation.maxRetries) {
            console.log(`Tentando novamente (${nextOperation.retryCount + 1}/${nextOperation.maxRetries}) após ${nextOperation.currentBackoff}ms...`);
            
            // Incrementar contador de tentativas e backoff
            nextOperation.retryCount++;
            nextOperation.currentBackoff = Math.min(nextOperation.currentBackoff * 2, 5000); // Backoff exponencial, máximo 5 segundos
            
            // Colocar de volta na fila
            setTimeout(() => {
                gattOperationQueue.unshift(nextOperation);
                processGattQueue();
            }, nextOperation.currentBackoff);
            return;
        } else {
            console.error('Número máximo de tentativas excedido');
            nextOperation.reject(error);
        }
    } finally {
        // Processar próxima operação após um pequeno intervalo
        setTimeout(() => {
            processGattQueue();
        }, 200);
    }
}

// Função para conectar ao bastão Bluetooth
async function conectarBastao() {
    try {
        const bastaoStatusDiv = document.getElementById('bastaoStatus');
        bastaoStatusDiv.textContent = "Conectando...";
        
        // Verificar se já está conectado
        if (bastaoDevice && bastaoDevice.gatt.connected) {
            console.log('Bastão já está conectado');
            bastaoStatusDiv.textContent = "Conectado a " + bastaoDevice.name;
            return;
        }
        
        // Solicitar dispositivo Bluetooth
        bastaoDevice = await navigator.bluetooth.requestDevice({
            // Aceitar qualquer dispositivo Bluetooth para garantir a descoberta
            acceptAllDevices: true,
            // Incluir serviços que não estão bloqueados
            optionalServices: [
                '6e400001-b5a3-f393-e0a9-e50e24dcca9e', // UART
                '0000ffe0-0000-1000-8000-00805f9b34fb', // FFE0
                '0000fff0-0000-1000-8000-00805f9b34fb', // FFF0
                '00001812-0000-1000-8000-00805f9b34fb', // HID
                '0000180a-0000-1000-8000-00805f9b34fb', // Device Information
                'device_information',
                '00001800-0000-1000-8000-00805f9b34fb', // Generic Access
                '00001801-0000-1000-8000-00805f9b34fb', // Generic Attribute
                '0000180f-0000-1000-8000-00805f9b34fb'  // Battery Service
            ]
        });
        
        // Adicionar listener para desconexão
        bastaoDevice.addEventListener('gattserverdisconnected', onBastaoDisconnected);
        
        // Conectar ao GATT server
        console.log('Conectando ao GATT server do bastão...');
        const server = await executeGattOperation(() => bastaoDevice.gatt.connect());
        
        // Descobrir serviços
        console.log('Descobrindo serviços...');
        const services = await executeGattOperation(() => server.getPrimaryServices());
        console.log('Serviços descobertos:', services.map(s => s.uuid));
        
        // Procurar por características em cada serviço
        let foundCharacteristic = false;
        
        for (const service of services) {
            try {
                console.log('Descobrindo características para serviço:', service.uuid);
                const characteristics = await executeGattOperation(() => service.getCharacteristics());
                console.log('Características descobertas:', characteristics.map(c => c.uuid));
                
                // Procurar por características conhecidas
                const targetCharUUIDs = [
                    '6e400003-b5a3-f393-e0a9-e50e24dcca9e', // UART RX
                    '0000ffe1-0000-1000-8000-00805f9b34fb', // FFE1
                    '0000fff1-0000-1000-8000-00805f9b34fb'  // FFF1
                ];
                
                for (const uuid of targetCharUUIDs) {
                    const char = characteristics.find(c => c.uuid === uuid);
                    if (char) {
                        bastaoCharacteristic = char;
                        console.log('Encontrada característica alvo:', uuid);
                        foundCharacteristic = true;
                        break;
                    }
                }
                
                if (foundCharacteristic) break;
                
                // Se não encontrou características conhecidas, procurar por qualquer uma que suporte notificações
                if (!bastaoCharacteristic) {
                    const notifyChar = characteristics.find(c => c.properties.notify || c.properties.indicate);
                    if (notifyChar) {
                        bastaoCharacteristic = notifyChar;
                        console.log('Usando característica com notificação:', notifyChar.uuid);
                        foundCharacteristic = true;
                        break;
                    }
                }
                
                // Se ainda não encontrou, procurar por qualquer uma que suporte leitura
                if (!bastaoCharacteristic) {
                    const readChar = characteristics.find(c => c.properties.read);
                    if (readChar) {
                        bastaoCharacteristic = readChar;
                        console.log('Usando característica com leitura:', readChar.uuid);
                        foundCharacteristic = true;
                        break;
                    }
                }
            } catch (error) {
                console.warn('Erro ao descobrir características para serviço', service.uuid, error);
            }
        }
        
        if (!bastaoCharacteristic) {
            throw new Error('Não foi possível encontrar uma característica compatível no bastão');
        }
        
        // Iniciar notificações ou leitura periódica
        if (bastaoCharacteristic.properties.notify || bastaoCharacteristic.properties.indicate) {
            console.log('Iniciando notificações para o bastão...');
            await executeGattOperation(() => bastaoCharacteristic.startNotifications());
            bastaoCharacteristic.addEventListener('characteristicvaluechanged', handleBastaoValueChanged);
            bastaoNotificationsStarted = true;
        } else if (bastaoCharacteristic.properties.read) {
            console.log('Configurando leitura periódica para o bastão...');
            
            // Adiciona um atraso antes da primeira leitura
            setTimeout(async () => {
                // Tenta ler o valor inicial
                try {
                    await executeGattOperation(() => bastaoCharacteristic.readValue());
                    const initialValue = bastaoCharacteristic.value;
                    handleBastaoValueChanged({ target: { value: initialValue } });
                    bastaoErrorCount = 0; // Resetar contador de erros
                } catch (error) {
                    console.error('Erro na leitura inicial do bastão:', error);
                    bastaoErrorCount++;
                }

                // Configura leitura periódica com um intervalo maior
                console.log('Configurando leitura periódica para o bastão...');
                bastaoReadInterval = setInterval(async () => {
                    if (!bastaoCharacteristic) {
                        console.log('Característica do bastão não disponível, interrompendo leitura');
                        clearInterval(bastaoReadInterval);
                        bastaoReadInterval = null;
                        return;
                    }
                    
                    try {
                        await executeGattOperation(() => bastaoCharacteristic.readValue());
                        const value = bastaoCharacteristic.value;
                        handleBastaoValueChanged({ target: { value } });
                        bastaoErrorCount = 0; // Resetar contador de erros após leitura bem-sucedida
                    } catch (error) {
                        console.error('Erro na leitura periódica do bastão:', error);
                        bastaoErrorCount++;
                        if (bastaoErrorCount > 5) {
                            console.log('Muitos erros consecutivos, interrompendo leitura periódica');
                            clearInterval(bastaoReadInterval);
                            bastaoReadInterval = null;
                        }
                    }
                }, 1500); // Aumentado para 1.5 segundos
            }, 500); // Atraso de 500ms antes da primeira leitura
        } else {
            throw new Error('A característica não suporta notificações nem leitura');
        }
        
        bastaoStatusDiv.textContent = "Conectado a " + bastaoDevice.name;
        mostrarNotificacao("Bastão conectado com sucesso!", "success");
        
    } catch (error) {
        console.error('Erro ao conectar ao bastão:', error);
        const bastaoStatusDiv = document.getElementById('bastaoStatus');
        bastaoStatusDiv.textContent = "Erro: " + error.message;
        mostrarNotificacao("Erro ao conectar ao bastão: " + error.message, "error");
        throw error;
    }
}

// Função para processar as leituras do bastão
function handleBastaoValueChanged(event) {
    try {
        const value = event.target.value;
        const brincoInput = document.getElementById('brinco');
        
        // Exibir dados brutos para depuração
        console.log('Dados brutos recebidos do bastão:', Array.from(new Uint8Array(value.buffer)).map(b => b.toString(16).padStart(2, '0')).join(' '));
        
        // Tentar diferentes decodificações
        const decoder = new TextDecoder('utf-8');
        let brincoLido = decoder.decode(value).trim();
        
        // Se o brinco estiver vazio ou contiver apenas caracteres nulos, tente outras abordagens
        if (!brincoLido || /^[\x00\s]*$/.test(brincoLido)) {
            // Tentar extrair caracteres ASCII válidos
            const bytes = new Uint8Array(value.buffer);
            const asciiChars = [];
            
            for (let i = 0; i < bytes.length; i++) {
                // Considerar apenas caracteres ASCII imprimíveis (32-126)
                if (bytes[i] >= 32 && bytes[i] <= 126) {
                    asciiChars.push(String.fromCharCode(bytes[i]));
                }
            }
            
            if (asciiChars.length > 0) {
                brincoLido = asciiChars.join('');
                console.log('Brinco extraído de caracteres ASCII:', brincoLido);
            }
            
            // Se ainda estiver vazio, tente interpretar como número
            if (!brincoLido || /^[\x00\s]*$/.test(brincoLido)) {
                // Tentar interpretar como número (big-endian e little-endian)
                if (bytes.length >= 4) {
                    const view = new DataView(value.buffer);
                    const numBE = view.getUint32(0, false); // Big Endian
                    const numLE = view.getUint32(0, true);  // Little Endian
                    
                    console.log('Possíveis interpretações numéricas:', {
                        bigEndian: numBE,
                        littleEndian: numLE
                    });
                    
                    // Usar o número se for razoável (não zero e não muito grande)
                    if (numBE > 0 && numBE < 1000000000) {
                        brincoLido = numBE.toString();
                        console.log('Usando interpretação numérica (BE):', brincoLido);
                    } else if (numLE > 0 && numLE < 1000000000) {
                        brincoLido = numLE.toString();
                        console.log('Usando interpretação numérica (LE):', brincoLido);
                    }
                }
            }
        }
        
        console.log('Brinco lido após processamento:', brincoLido);
        
        // Verificar se o brinco é válido (não vazio e não contém apenas caracteres nulos)
        const brincoValido = brincoLido && 
                            !/^[\x00\s]*$/.test(brincoLido) && // Não contém apenas nulos ou espaços
                            brincoLido.length > 1 && // Tem pelo menos 2 caracteres
                            brincoLido.length < 30; // Não é muito longo (provavelmente erro)
        
        // Verificar se já passou tempo suficiente desde a última leitura (500ms)
        const agora = Date.now();
        const tempoSuficiente = (agora - ultimaLeituraBrinco) > 500;
        
        // Verificar se é diferente do último brinco lido
        const brincoNovo = brincoLido !== ultimoBrincoLido;
        
        console.log('Dados recebidos do bastão:', {
            bruto: brincoLido,
            valido: brincoValido,
            novo: brincoNovo,
            tempoSuficiente: tempoSuficiente
        });
        
        // Só processa se for um brinco válido, novo e tiver passado tempo suficiente
        if (brincoValido && (brincoNovo || tempoSuficiente)) {
            console.log('Brinco válido lido:', brincoLido);
            
            // Atualizar variáveis de controle
            ultimoBrincoLido = brincoLido;
            ultimaLeituraBrinco = agora;
            
            // Preencher o campo de brinco
            brincoInput.value = brincoLido;
            
            // Disparar evento de busca de animal
            buscarAnimal(brincoLido);
            
            // Reproduzir beep de confirmação
            beep();
            
            // Focar no próximo campo se automação estiver ativa
            if (automationActive) {
                pesoInput.focus();
            }
            
            // Mostrar notificação
            mostrarNotificacao("Brinco lido: " + brincoLido, "success");
        }
    } catch (error) {
        console.error('Erro ao processar leitura do bastão:', error);
    }
}

// Função para tratar desconexão do bastão
function onBastaoDisconnected() {
    bastaoNotificationsStarted = false;
    bastaoCharacteristic = null;
    
    // Limpar intervalo de leitura se existir
    if (bastaoReadInterval) {
        clearInterval(bastaoReadInterval);
        bastaoReadInterval = null;
    }
    
    const bastaoStatusDiv = document.getElementById('bastaoStatus');
    bastaoStatusDiv.textContent = "Desconectado";
    const bastaoBtn = document.getElementById('conectarBastao');
    if (bastaoBtn) {
        bastaoBtn.textContent = "Reconectar";
    }
}

// Função para conectar à balança Bluetooth
async function conectarBalanca() {
    try {
        const balancaStatusDiv = document.getElementById('balancaStatus');
        balancaStatusDiv.textContent = "Conectando...";
        
        // Verificar se já está conectado
        if (balancaDevice && balancaDevice.gatt.connected) {
            console.log('Balança já está conectada');
            balancaStatusDiv.textContent = "Conectado a " + balancaDevice.name;
            document.getElementById('peso').disabled = false;
            return;
        }
        
        // Solicitar dispositivo Bluetooth
        balancaDevice = await navigator.bluetooth.requestDevice({
            // Aceitar qualquer dispositivo Bluetooth para garantir a descoberta
            acceptAllDevices: true,
            // Incluir serviços que não estão bloqueados
            optionalServices: [
                '6e400001-b5a3-f393-e0a9-e50e24dcca9e', // UART
                '0000ffe0-0000-1000-8000-00805f9b34fb', // FFE0
                '0000fff0-0000-1000-8000-00805f9b34fb', // FFF0
                '00001812-0000-1000-8000-00805f9b34fb', // HID
                '0000180a-0000-1000-8000-00805f9b34fb', // Device Information
                'device_information',
                '00001800-0000-1000-8000-00805f9b34fb', // Generic Access
                '00001801-0000-1000-8000-00805f9b34fb', // Generic Attribute
                '0000180f-0000-1000-8000-00805f9b34fb'  // Battery Service
            ]
        });
        
        // Adicionar listener para desconexão
        balancaDevice.addEventListener('gattserverdisconnected', onBalancaDisconnected);
        
        // Conectar ao GATT server
        console.log('Conectando ao GATT server da balança...');
        const server = await executeGattOperation(() => balancaDevice.gatt.connect());
        
        // Descobrir serviços
        console.log('Descobrindo serviços...');
        const services = await executeGattOperation(() => server.getPrimaryServices());
        console.log('Serviços descobertos:', services.map(s => s.uuid));
        
        // Procurar por características em cada serviço
        let foundCharacteristic = false;
        
        for (const service of services) {
            try {
                console.log('Descobrindo características para serviço:', service.uuid);
                const characteristics = await executeGattOperation(() => service.getCharacteristics());
                console.log('Características descobertas:', characteristics.map(c => c.uuid));
                
                // Procurar por características conhecidas
                const targetCharUUIDs = [
                    '6e400003-b5a3-f393-e0a9-e50e24dcca9e', // UART RX
                    '0000ffe1-0000-1000-8000-00805f9b34fb', // FFE1
                    '0000fff1-0000-1000-8000-00805f9b34fb'  // FFF1
                ];
                
                for (const uuid of targetCharUUIDs) {
                    const char = characteristics.find(c => c.uuid === uuid);
                    if (char) {
                        balancaCharacteristic = char;
                        console.log('Encontrada característica alvo:', uuid);
                        foundCharacteristic = true;
                        break;
                    }
                }
                
                if (foundCharacteristic) break;
                
                // Se não encontrou características conhecidas, procurar por qualquer uma que suporte notificações
                if (!balancaCharacteristic) {
                    const notifyChar = characteristics.find(c => c.properties.notify || c.properties.indicate);
                    if (notifyChar) {
                        balancaCharacteristic = notifyChar;
                        console.log('Usando característica com notificação:', notifyChar.uuid);
                        foundCharacteristic = true;
                        break;
                    }
                }
                
                // Se ainda não encontrou, procurar por qualquer uma que suporte leitura
                if (!balancaCharacteristic) {
                    const readChar = characteristics.find(c => c.properties.read);
                    if (readChar) {
                        balancaCharacteristic = readChar;
                        console.log('Usando característica com leitura:', readChar.uuid);
                        foundCharacteristic = true;
                        break;
                    }
                }
            } catch (error) {
                console.warn('Erro ao descobrir características para serviço', service.uuid, error);
            }
        }
        
        if (!balancaCharacteristic) {
            throw new Error('Não foi possível encontrar uma característica compatível na balança');
        }
        
        // Iniciar notificações ou leitura periódica
        if (balancaCharacteristic.properties.notify || balancaCharacteristic.properties.indicate) {
            console.log('Iniciando notificações para a balança...');
            await executeGattOperation(() => balancaCharacteristic.startNotifications());
            balancaCharacteristic.addEventListener('characteristicvaluechanged', handleBalancaValueChanged);
            balancaNotificationsStarted = true;
        } else if (balancaCharacteristic.properties.read) {
            console.log('Configurando leitura periódica para a balança...');
            
            // Adiciona um atraso antes da primeira leitura
            setTimeout(async () => {
                // Tenta ler o valor inicial
                try {
                    await executeGattOperation(() => balancaCharacteristic.readValue());
                    const initialValue = balancaCharacteristic.value;
                    handleBalancaValueChanged({ target: { value: initialValue } });
                    balancaErrorCount = 0; // Resetar contador de erros
                } catch (error) {
                    console.error('Erro na leitura inicial da balança:', error);
                    balancaErrorCount++;
                }

                // Configura leitura periódica com um intervalo maior
                console.log('Configurando leitura periódica para a balança...');
                balancaReadInterval = setInterval(async () => {
                    if (!balancaCharacteristic || !balancaDevice || !balancaDevice.gatt.connected) {
                        console.log('Balança desconectada ou característica não disponível, interrompendo leitura');
                        clearInterval(balancaReadInterval);
                        balancaReadInterval = null;
                        return;
                    }
                    
                    try {
                        await executeGattOperation(() => balancaCharacteristic.readValue());
                        const value = balancaCharacteristic.value;
                        handleBalancaValueChanged({ target: { value } });
                        balancaErrorCount = 0; // Resetar contador de erros após leitura bem-sucedida
                    } catch (error) {
                        console.error('Erro na leitura periódica da balança:', error);
                        balancaErrorCount++;
                        if (balancaErrorCount > MAX_CONSECUTIVE_GATT_ERRORS) {
                            console.log('Muitos erros consecutivos, interrompendo leitura periódica');
                            clearInterval(balancaReadInterval);
                            balancaReadInterval = null;
                        }
                    }
                }, 1000); // Intervalo de 1 segundo para a balança
            }, 500); // Atraso de 500ms antes da primeira leitura
        } else {
            throw new Error('A característica não suporta notificações nem leitura');
        }
        
        balancaStatusDiv.textContent = "Conectado a " + balancaDevice.name;
        document.getElementById('peso').disabled = false;
        mostrarNotificacao("Balança conectada com sucesso!", "success");
        
    } catch (error) {
        console.error('Erro ao conectar à balança:', error);
        const balancaStatusDiv = document.getElementById('balancaStatus');
        balancaStatusDiv.textContent = "Erro: " + error.message;
        document.getElementById('peso').disabled = true;
        mostrarNotificacao("Erro ao conectar à balança: " + error.message, "error");
        throw error;
    }
}

// Função para processar os dados recebidos da balança
function handleBalancaValueChanged(event) {
    try {
        const value = event.target.value;
        const bytes = new Uint8Array(value.buffer);
        
        // Exibir dados brutos para depuração
        console.log('Dados brutos recebidos da balança:', Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' '));
        
        // Variável para armazenar o peso processado
        let pesoStr = '';
        
        // Abordagem 1: Tentar decodificar como texto UTF-8
        const decoder = new TextDecoder('utf-8');
        let textoDecodificado = decoder.decode(value).trim();
        console.log('Dados da balança (texto):', textoDecodificado);
        
        // Extrair apenas números, ponto e vírgula do texto
        if (textoDecodificado) {
            pesoStr = textoDecodificado.replace(/[^0-9.,]/g, '');
            if (pesoStr) {
                console.log('Peso extraído do texto:', pesoStr);
            }
        }
        
        // Abordagem 2: Se o texto não contiver números válidos, tentar extrair caracteres ASCII
        if (!pesoStr || /^[\x00\s]*$/.test(pesoStr)) {
            const asciiChars = [];
            
            for (let i = 0; i < bytes.length; i++) {
                // Considerar apenas caracteres ASCII imprimiíveis (32-126) e números (48-57)
                if ((bytes[i] >= 48 && bytes[i] <= 57) || bytes[i] === 46 || bytes[i] === 44) { // 0-9, ., ,
                    asciiChars.push(String.fromCharCode(bytes[i]));
                }
            }
            
            if (asciiChars.length > 0) {
                pesoStr = asciiChars.join('');
                console.log('Peso extraído de caracteres ASCII:', pesoStr);
            }
        }
        
        // Abordagem 3: Tentar interpretar como número (float)
        if (!pesoStr && bytes.length >= 4) {
            const dataView = new DataView(value.buffer);
            
            // Tentar interpretar como float (little-endian e big-endian)
            const floatLE = dataView.getFloat32(0, true); // little-endian
            const floatBE = dataView.getFloat32(0, false); // big-endian
            
            console.log('Dados interpretados como float:', 'LE:', floatLE, 'BE:', floatBE);
            
            // Escolher o valor mais provável (não negativo e menor que 10000)
            if (floatLE >= 0 && floatLE < 10000 && !isNaN(floatLE)) {
                pesoStr = floatLE.toFixed(2);
                console.log('Usando valor float LE:', pesoStr);
            } else if (floatBE >= 0 && floatBE < 10000 && !isNaN(floatBE)) {
                pesoStr = floatBE.toFixed(2);
                console.log('Usando valor float BE:', pesoStr);
            }
        }
        
        // Abordagem 4: Tentar interpretar como número (int16)
        if (!pesoStr && bytes.length >= 2) {
            const dataView = new DataView(value.buffer);
            
            // Tentar interpretar como int16 (little-endian e big-endian)
            const int16LE = dataView.getInt16(0, true); // little-endian
            const int16BE = dataView.getInt16(0, false); // big-endian
            
            console.log('Dados interpretados como int16:', 'LE:', int16LE, 'BE:', int16BE);
            
            // Escolher o valor mais provável (não negativo e menor que 10000)
            if (int16LE >= 0 && int16LE < 10000) {
                pesoStr = int16LE.toString();
                console.log('Usando valor int16 LE:', pesoStr);
            } else if (int16BE >= 0 && int16BE < 10000) {
                pesoStr = int16BE.toString();
                console.log('Usando valor int16 BE:', pesoStr);
            }
        }
        
        // Abordagem 5: Tentar interpretar como número (uint8)
        if (!pesoStr && bytes.length >= 1) {
            // Algumas balanças enviam apenas um byte com o peso
            const uint8Value = bytes[0];
            if (uint8Value > 0 && uint8Value < 255) {
                pesoStr = uint8Value.toString();
                console.log('Usando valor uint8:', pesoStr);
            }
        }
        
        // Processar e validar o peso encontrado
        if (pesoStr) {
            // Substituir vírgula por ponto para garantir formato numérico
            pesoStr = pesoStr.replace(',', '.');
            
            // Converter para número
            const peso = parseFloat(pesoStr);
            
            // Validar se é um número válido e dentro de um intervalo razoável
            if (!isNaN(peso) && peso > 0 && peso < 10000) {
                const agora = Date.now();
                
                // Verificar se é uma nova leitura ou se passou tempo suficiente desde a última leitura
                if (peso !== ultimoPesoLido || (agora - ultimaLeituraBalanca) > 2000) {
                    console.log('Peso válido recebido:', peso);
                    
                    // Atualizar campo de peso
                    const pesoInput = document.getElementById('peso');
                    if (pesoInput) {
                        pesoInput.value = peso.toFixed(2);
                        pesoInput.dispatchEvent(new Event('change')); // Disparar evento de mudança
                    }
                    
                    // Atualizar variáveis de controle
                    ultimoPesoLido = peso;
                    ultimaLeituraBalanca = agora;
                    
                    // Mostrar notificação discreta
                    mostrarNotificacao(`Peso lido: ${peso.toFixed(2)} kg`, "info", 1500);
                }
            } else {
                console.warn('Valor de peso inválido:', peso);
            }
        } else {
            console.warn('Não foi possível extrair um valor de peso válido');
        }
    } catch (error) {
        console.error('Erro ao processar dados da balança:', error);
    }
}

// Função para lidar com a desconexão da balança
function onBalancaDisconnected() {
    balancaNotificationsStarted = false;
    balancaCharacteristic = null;
    if (balancaReadInterval) {
        clearInterval(balancaReadInterval);
        balancaReadInterval = null;
    }
    const balancaStatusDiv = document.getElementById('balancaStatus');
    balancaStatusDiv.textContent = "Desconectado";
    const balancaBtn = document.getElementById('conectarBalanca');
    if (balancaBtn) {
        balancaBtn.textContent = "Reconectar";
    }
    document.getElementById('peso').disabled = true;
}

// Adicionar event listeners para os botões de conexão Bluetooth
document.addEventListener('DOMContentLoaded', function() {
    // Event listener para o botão do bastão
    const conectarBastaoBtn = document.getElementById('conectarBastao');
    if (conectarBastaoBtn) {
        conectarBastaoBtn.addEventListener('click', function() {
            conectarBastao().catch(error => {
                console.error('Erro ao conectar bastão:', error);
                const bastaoStatusDiv = document.getElementById('bastaoStatus');
                bastaoStatusDiv.textContent = "Erro: " + error.message;
                mostrarNotificacao("Erro ao conectar bastão: " + error.message, "error");
            });
        });
    }
    
    // Event listener para o botão da balança
    const conectarBalancaBtn = document.getElementById('conectarBalanca');
    if (conectarBalancaBtn) {
        conectarBalancaBtn.addEventListener('click', function() {
            conectarBalanca().catch(error => {
                console.error('Erro ao conectar balança:', error);
                const balancaStatusDiv = document.getElementById('balancaStatus');
                balancaStatusDiv.textContent = "Erro: " + error.message;
                mostrarNotificacao("Erro ao conectar balança: " + error.message, "error");
            });
        });
    }
});
</script>
{% endblock %}